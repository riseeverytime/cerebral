import { InfernoChildren, VNode } from 'inferno';
import { ControllerClass, SignalChain } from 'cerebral'
import Component from 'inferno-component';

// TODO: Replace these type with Inferno JSX support
type ComponentState = {};
type Validator<T> = (object: T, key: string, componentName: string, ...rest: any[]) => Error | null;
type ValidationMap<T> = {[K in keyof T]?: Validator<T> };

interface ComponentClass<P = {}> {
    new (props?: P, context?: any): Component<P, ComponentState>;
    propTypes?: ValidationMap<P>;
    contextTypes?: ValidationMap<any>;
    childContextTypes?: ValidationMap<any>;
    defaultProps?: Partial<P>;
    displayName?: string;
}

interface InfernoJSXElement<P> extends VNode {}
interface StatelessComponent<P = {}> {
    (props: P & { children?: InfernoChildren }, context?: any): InfernoJSXElement<any> | null;
    propTypes?: ValidationMap<P>;
    contextTypes?: ValidationMap<any>;
    defaultProps?: Partial<P>;
    displayName?: string;
}

type ComponentType<P = {}> = ComponentClass<P> | StatelessComponent<P>;

declare global {
    namespace JSX {
        interface Element extends InfernoJSXElement<any> {}

        interface IntrinsicElements {
            [elemName: string]: any;
        }
    }
}

// TODO: expose SignalsMap from cerebral
interface SignalsMap {
    [signalName: string]: SignalChain
}

export const StateContainer: ComponentClass<{state: any, signals: SignalsMap}>
export const Container: ComponentClass<{controller: ControllerClass}>

type PropsMap<T> = {
    [P in keyof T]: any; // TODO: use correct type than Tag<any>
}

// Props are signal/state props, EProps are external props
export function connect<Props, EProps = {}>(props: Props, comp: ComponentType<PropsMap<Props> & EProps>): ComponentClass<EProps>
