import { InfernoChildren, Props as InfernoProps } from 'inferno';
import InfernoComponent from 'inferno-component';
import { ResolveValue } from 'function-tree'
import { ControllerClass, SignalChain } from 'cerebral';

type ComponentState = {} | void;

interface InfernoComponentClass<P> {
    new (props?: P, context?: any): InfernoComponent<P, ComponentState>;
}

interface FunctionalInfernoComponent<P> {
    (props: P & { children?: InfernoChildren }, context?: any): InfernoChildren;
}

type InfernoCompnentType<P> = InfernoComponentClass<P> | FunctionalInfernoComponent<P>;

// TODO: expose SignalsMap from cerebral
interface SignalsMap {
    [signalName: string]: SignalChain
}

export const StateContainer: InfernoComponentClass<{state: any, signals: SignalsMap, children?: InfernoChildren}>
export const Container: InfernoComponentClass<{controller: ControllerClass, children?: InfernoChildren}>

// TODO: expose PropsMap from cerebral
interface PropsMap {
    [prop: string]: ResolveValue<any>
}

export function connect<P extends PropsMap>(props: P, comp: InfernoCompnentType<Record<keyof P, any>>): InfernoComponentClass<P>
