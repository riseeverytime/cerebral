# @cerebral/fluent

## Install

`npm install @cerebral/fluent`

## Description
This addon gives you full typesafety using [TypeScript](https://www.typescriptlang.org/). It exposes a chainable API and types to be used with defining your modules, sequences, actions and connecting to components.

Currently only [React](https://reactjs.org/) is supported.

To enable type safe mutations the model of this addon is based on [Mobx](https://mobx.js.org/).


## Controller

```ts
import { Controller } from '@cerebral/fluent'
import { app, State, Signals } from './app'

const controller = Controller<State, Signals>(app)
```

The `State` and `Signals` type are not required, but will enable auto suggestions on:

```ts
controller.state
controller.signals
```

## Module

```ts
import { Module, Signal } from '@cerebral/fluent'
import * as sequences from './sequences'

type State = {
  foo: string
}

type Signals = {
  thisHappened: Signal
}

const state: State = {
  foo: 'bar'
}

const signals: Signals = {
  thisHappened: sequences.doThis
}

const controller = Module({
  state,
  signals
})
```

## Connect

### factory
```ts
import { ConnectFactory, Signal } from '@cerebral/fluent'

type State = {
  foo: string
}

type Signals = {
  thisHappened: Signal
}


export function connect<Props>() {
  return ConnectFactory<Props, State, Signals>();
}
```

### with

```ts
import * as React from 'react'
import { connect } from '../app'

type Props = {
  externalProp: string
}

export const App = connect<Props>()
  .with(({ state, signals, props }) => ({
    foo: state.foo,
    onClick: signals.thisHappened
  }))
```

### to

```ts
import * as React from 'react'
import { connect } from '../app'

type Props = {
  externalProp: string
}

export const App = connect<Props>()
  .with(({ state, signals, props }) => ({
    foo: state.foo,
    onClick: signals.thisHappened
  }))
  .to(
    function App ({ foo, onClick, externalProp }) {
      return <div></div>
    }
  )
```

### toClass

```ts
import * as React from 'react'
import { connect } from '../app'

type Props = {
  externalProp: string
}

export const App = connect<Props>()
  .with(({ state, signals, props }) => ({
    foo: state.foo,
    onClick: signals.thisHappened
  }))
  .toClass(props =>
    class App extends React.Component<typeof props> {
      render () {
        const { foo, onClick, externalProp } = this.props

        return <div></div>
      }
    }
  )
```

## Computed

```ts
import { Module, Signal, ComputedValue, Computed } from '@cerebral/fluent'
import * as sequences from './sequences'

type State = {
  items: string[],
  currentItemIndex: number,
  currentItem: ComputedValue<string>
}

const state: State = {
  items: [],
  currentItemIndex: -1,
  currentItem: Computed(state => state.items[state.currentItemIndex])
}

const controller = Module({
  state
})
```

## Types

### FluentContext

```ts
import { FluentContext } from '@cerebral/fluent'
import { HttpProvider } from '@cerebral/http'

export type State = {
  foo: string
}

export interface Providers {
  http: HttpProvider
}

export interface Context<Props> extends FluentContext<Props>, Providers {
  state: State
}
```

### FluentContextWithPaths

```ts
import { FluentContextWithPaths } from '@cerebral/fluent'
import { HttpProvider } from '@cerebral/http'

export type State = {
  foo: string
}

export interface Providers {
  http: HttpProvider
}

export interface ContextWithPaths<Props, Paths> extends  FluentContextWithPaths<Props, Paths>, Providers {
  state: State
}
```

### Signal

```ts
import { Signal } from '@cerebral/fluent'

type Signals = {
  thisHappened: Signal
}
```

### SignalWithPayload

```ts
import { SignalWithPayload } from '@cerebral/fluent'

type Signals = {
  thisHappened: SignalWithPayload<{ foo: string }>
}
```

### ComputedValue

```ts
import { ComputedValue } from '@cerebral/fluent'

type State = {
  someComputedString: ComputedValue<string>
}

```