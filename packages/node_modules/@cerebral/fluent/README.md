# @cerebral/fluent

## Install

`npm install @cerebral/fluent`

## Description
This addon gives you full typesafety using [TypeScript](https://www.typescriptlang.org/). It exposes a chainable API and types to be used with defining your modules, sequences, actions and connecting to components.

Currently only [React](https://reactjs.org/) is supported.

To enable type safe mutations the model of this addon is based on [Mobx](https://mobx.js.org/).

## action

```ts
import { Sequence } from '@cerebral/fluent'
import * as actions from './actions'

export const doThis = Sequence(s => s
  .action(actions.doSomething)
)
```

## branch

```ts
import { Sequence } from '@cerebral/fluent'
import * as actions from './actions'

export const doThis = Sequence(s => s
  .branch(actions.doSomething)
)
```


## computed

```ts
import { Module, ComputedValue, Computed } from '@cerebral/fluent'
import * as sequences from './sequences'

type State = {
  items: string[],
  currentItemIndex: number,
  currentItem: ComputedValue<string>
}

const state: State = {
  items: [],
  currentItemIndex: -1,
  currentItem: Computed(state => state.items[state.currentItemIndex])
}

const controller = Module({
  state
})
```

## connect

### factory
```ts
import { ConnectFactory } from '@cerebral/fluent'
import { State, Signals } from './app'

export function connect<Props>() {
  return ConnectFactory<Props, State, Signals>();
}
```

### with

```ts
import * as React from 'react'
import { connect } from '../app'

type Props = {
  externalProp: string
}

export const App = connect<Props>()
  .with(({ state, signals, props }) => ({
    foo: state.foo,
    onClick: signals.thisHappened
  }))
```

### to

```ts
import * as React from 'react'
import { connect } from '../app'

type Props = {
  externalProp: string
}

export const App = connect<Props>()
  .with(({ state, signals, props }) => ({
    foo: state.foo,
    onClick: signals.thisHappened
  }))
  .to(
    function App ({ foo, onClick, externalProp }) {
      return <div></div>
    }
  )
```

### toClass

```ts
import * as React from 'react'
import { connect } from '../app'

type Props = {
  externalProp: string
}

export const App = connect<Props>()
  .with(({ state, signals, props }) => ({
    foo: state.foo,
    onClick: signals.thisHappened
  }))
  .toClass(props =>
    class App extends React.Component<typeof props> {
      render () {
        const { foo, onClick, externalProp } = this.props

        return <div></div>
      }
    }
  )
```

## controller

```ts
import { Controller } from '@cerebral/fluent'
import { app, State, Signals } from './app'

const controller = Controller<State, Signals>(app)
```

The **State** and **Signals** type are not required, but will enable auto suggestions on:

```ts
controller.state
controller.signals
```

## dictionary

```ts
import { Dictionary } from '@cerebral/fluent'
import * as signals from './sequences'

export type Signals = {
  [key in keyof typeof signals]: typeof signals[key]
}

export type State = {
  foo: string
}

const state: State = {
  foo: 'bar'
}

const controller = Module({
  state,
  signals
})
```

## debounce

```ts
import { Sequence } from '@cerebral/fluent'
import * as actions from './actions'

export const doThis = Sequence(s => s
  .debounce(100)
)
```

## equals

```ts
import { Sequence } from '@cerebral/fluent'
import * as actions from './actions'

export const doThis = Sequence(s => s
  .equals(({ state }) => state.user.role)
  .paths({
    admin: s => s,
    user: s => s,
    otherwise: s => s
  })
)
```

## IContext

```ts
import { IBranchContext } from '@cerebral/fluent'
import { HttpProvider } from '@cerebral/http'

export type State = {
  foo: string
}

export interface Providers {
  http: HttpProvider
}

export interface Context<Props> extends IBranchContext  <Props>, Providers {
  state: State
}
```

## IBranchContext

```ts
import { IBranchContext } from '@cerebral/fluent'
import { HttpProvider } from '@cerebral/http'

export type State = {
  foo: string
}

export interface Providers {
  http: HttpProvider
}

export interface BranchContext<Props, Paths> extends IBranchContext<Props, Paths>, Providers {
  state: State
}
```

## module

```ts
import { Module } from '@cerebral/fluent'
import * as signals from './sequences'

export type Signals = {
  [key in keyof typeof signals]: typeof signals[key]
}

export type State = {
  foo: string
}

const state: State = {
  foo: 'bar'
}

const controller = Module({
  state,
  signals
})
```

## paths

```ts
import { Sequence } from '@cerebral/fluent'
import * as actions from './actions'

export const doThis = Sequence(s => s
  .branch(actions.doThis)
  .paths({
    success: s => s,
    error: s => s
  })
)
```


## sequence

```ts
import { Sequence } from  '@cerebral/fluent'

export const doThis = Sequence(s => s)
```

## sequenceWithProps

```ts
import { sequenceWithProps } from  './fluent'

export const doThis = sequenceWithProps<{ foo: string }>(s => s)
```

## wait

```ts
import { Sequence } from  '@cerebral/fluent'

export const doThis = Sequence(s => s
  .wait(1000)
)
```

## when

```ts
import { Sequence } from  '@cerebral/fluent'

export const doThis = Sequence(s => s
  .when(({ state }) => state.isAwesome)
  .paths({
    true: s => s,
    false: s => s
  })
)
```

## TComputedValue

```ts
import { ComputedValue } from '@cerebral/fluent'

type State = {
  someComputedString: ComputedValue<string>
}
```

## TDictionary

```ts
import { TDictionary } from '@cerebral/fluent'

type Item = {
  title: string
}

export type State = {
  items: TDictionary<Item>
}
```

