import { extractModuleProp, isObject, throwError, BaseModel } from 'cerebral/internal';
import { BaseControllerClass, InstantiatedModuleObjectDefinition, Provider } from 'cerebral';
import {
    observable,
    isObservable,
    isObservableMap,
    isComputed,
    extendObservable,
    ObservableMap,
    useStrict,
    computed
} from 'mobx';
import { ComputedClass } from './Computed';
import { updateIn, traverse } from './utils';

const mutationMethods: PropertyKey[] = [ 'concat', 'pop', 'push', 'shift', 'splice', 'unshift' ];

const nonMutationObservableMapKeys: PropertyKey[] = [
    'has',
    'keys',
    'values',
    'entries',
    'isValidKey',
    '_hasMap',
    'forEach'
];

function cleanPath(state: any, key: PropertyKey | null, path: PropertyKey[]): PropertyKey[] {
    const pathCopy = key ? path.concat(key) : path.slice();
    let isValid = false;
    while (!isValid) {
        const value = pathCopy.reduce((currentState, pathKey) => {
            if (currentState === undefined) {
                return;
            }
            if (isObservableMap(currentState)) {
                return currentState.get(pathKey.toString());
            }

            if (typeof currentState === 'object' && pathKey in currentState) {
                return currentState[pathKey];
            }

            return;
        }, state);

        if (value === undefined) {
            pathCopy.splice(pathCopy.length - 2, 1);
        } else {
            isValid = true;
        }
    }

    return pathCopy;
}

function createValidator(state: any, execution: any, functionDetails: any, props: any, devtools: any) {
    let path: PropertyKey[] = [];

    var validator = {
        get(target: any, key: PropertyKey): any {
            if (isObservableMap(target)) {
                switch (key) {
                    case 'size':
                        path = cleanPath(state, null, path);
                        return target[key];
                    case 'forEach':
                        const originalFunc = target[key];
                        return (cb: any) => {
                            return target.keys().forEach((forEachKey, ...args: any[]) => {
                                path = cleanPath(state, forEachKey, path);
                                cb(new Proxy(target.get(forEachKey), validator), ...args);
                            });
                        };
                    case 'entries': {
                        const originalFunc = target[key];

                        return (...args: any[]) => {
                            const value = originalFunc.apply(target, args);
                            path = cleanPath(state, null, path);
                            return value;
                        };
                    }
                    case 'get': {
                        const originalFunc = target[key];
                        return (mapKey: string) => {
                            path = cleanPath(state, mapKey, path);
                            const value = originalFunc.call(target, mapKey);

                            return new Proxy(value, validator);
                        };
                    }
                    case 'delete': {
                        const originalFunction = target[key];
                        return (...args: any[]) => {
                            devtools.sendExecutionData(
                                {
                                    type: 'mutation',
                                    method: 'unset',
                                    args: [ path.concat(args[0]) ]
                                },
                                execution,
                                functionDetails,
                                props
                            );
                            path = cleanPath(state, args[0], path);
                            return originalFunction.apply(target, args);
                        };
                    }
                    case 'clear': {
                        const originalFunction = target[key];
                        return (...args: any[]) => {
                            devtools.sendExecutionData(
                                {
                                    type: 'mutation',
                                    method: 'set',
                                    args: [ path, {} ]
                                },
                                execution,
                                functionDetails,
                                props
                            );
                            path = cleanPath(state, null, path);
                            return originalFunction.apply(target, args);
                        };
                    }
                    case 'merge': {
                        const originalFunction = target[key];
                        return (...args: any[]) => {
                            devtools.sendExecutionData(
                                {
                                    type: 'mutation',
                                    method: 'merge',
                                    args: [ path, args[0] ]
                                },
                                execution,
                                functionDetails,
                                props
                            );
                            path = cleanPath(state, null, path);
                            return originalFunction.apply(target, args);
                        };
                    }
                    case 'replace':
                        const originalFunction = target[key];
                        return (...args: any[]) => {
                            devtools.sendExecutionData(
                                {
                                    type: 'mutation',
                                    method: 'set',
                                    args: [ path, args[0] ]
                                },
                                execution,
                                functionDetails,
                                props
                            );
                            path = cleanPath(state, null, path);
                            return originalFunction.apply(target, args);
                        };
                    case 'set': {
                        const originalFunction = target[key];
                        return (...args: any[]) => {
                            devtools.sendExecutionData(
                                {
                                    type: 'mutation',
                                    method: 'set',
                                    args: [ path.concat(args[0]), args[1] ]
                                },
                                execution,
                                functionDetails,
                                props
                            );
                            path = cleanPath(state, null, path);
                            return originalFunction.apply(target, args);
                        };
                    }
                    default:
                        return (<any>target)[key];
                }
            } else if (target[key] instanceof ComputedClass) {
                return target[key];
            } else if (typeof target[key] === 'object' && target[key] !== null) {
                path = cleanPath(state, key, path);
                return new Proxy(target[key], validator);
            } else {
                if (typeof target[key] === 'function' && mutationMethods.indexOf(key) >= 0) {
                    const originalFunction = target[key];
                    return (...args: any[]) => {
                        devtools.sendExecutionData(
                            {
                                type: 'mutation',
                                method: key,
                                args: [ path, ...args ]
                            },
                            execution,
                            functionDetails,
                            props
                        );
                        path = cleanPath(state, key, path);
                        return originalFunction.apply(target, args);
                    };
                }
                return target[key];
            }
        },
        set(target: any, key: PropertyKey, value: any) {
            path = cleanPath(state, key, path);
            devtools.sendExecutionData(
                {
                    type: 'mutation',
                    method: 'set',
                    args: [ path, isObservable(value) ? value.value : value ]
                },
                execution,
                functionDetails,
                props
            );

            Reflect.set(target, key, value);

            return true;
        }
    };

    return validator;
}

const legacyApi = [
    'get',
    'set',
    'toggle',
    'push',
    'merge',
    'pop',
    'shift',
    'unshift',
    'splice',
    'concat',
    'increment',
    'unset'
];
function CreateStateProvider(state: any, devtools: any, model: any, useLegacyStateApi: boolean) {
    if (!devtools && useLegacyStateApi) {
        legacyApi.forEach((method) => {
            Object.defineProperty(state, method, {
                value(path: string, ...args: any[]) {
                    return model[method](path.split('.'), ...args);
                }
            });
        });
    }

    return Provider(state, {
        wrap: devtools
            ? (context: any) => {
                  if (useLegacyStateApi) {
                      legacyApi.forEach((method) => {
                          Object.defineProperty(state, method, {
                              writable: true,
                              value(path: string, ...args: any[]) {
                                  if (method !== 'get') {
                                      devtools.sendExecutionData(
                                          {
                                              type: 'mutation',
                                              method: method,
                                              args: [ path.split('.') ].concat(
                                                  args.map((value) => (isObservable(value) ? value.value : value))
                                              )
                                          },
                                          context.execution,
                                          context.functionDetails,
                                          context.props
                                      );
                                  }
                                  return model[method](path.split('.'), ...args);
                              }
                          });
                      });
                  }
                  return new Proxy(
                      state,
                      createValidator(state, context.execution, context.functionDetails, context.props, devtools)
                  );
              }
            : false,
        ignoreDefinition: true
    });
}

class Model extends BaseModel {
    static useLegacyStateApi: boolean = false;
    constructor(controller: BaseControllerClass) {
        super(controller);
        this.state = extractModuleProp(controller.module, 'state', (state: any, module: any) => {
            return this.observeState(state);
        });
        this.StateProvider = (devtools: any) =>
            CreateStateProvider(this.state, devtools, this, Model.useLegacyStateApi);
    }
    // Used by initial state changed
    set(path: string[], value: any) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            if (isObservableMap(parentState)) {
                parentState.set(key, value);
            } else {
                parentState[key] = value;
            }
        });
    }
    toggle(path: string[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key] = !parentState[key];
        });
    }
    push(path: string[], value: any) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].push(value);
        });
    }
    merge(path: string[], mergeValue: {}, ...values: {}[]) {
        const value: {} = Object.assign(mergeValue, ...values);
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            if (isObservableMap(parentState[key])) {
                parentState[key].merge(value);
            } else {
                Object.assign(parentState[key], value);
            }
        });
    }
    pop(path: string[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].pop();
        });
    }
    shift(path: string[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].shift();
        });
    }
    unshift(path: string[], value: any) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].unshift(value);
        });
    }
    splice(path: string[], ...args: any[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].splice(...args);
        });
    }
    unset(path: string[]) {
        const deleteKey = path.pop();
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key].delete(deleteKey);
        });
    }
    concat(path: string[], value: any[]) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key] = parentState[key].concat(value);
        });
    }
    increment(path: string[], delta = 1) {
        updateIn(this.state, path, (parentState: { [key: string]: any }, key: string) => {
            parentState[key] += delta;
        });
    }
    get(path: string[]) {
        if (!path) {
            return this.state;
        }

        return path.reduce((currentState, key) => {
            if (currentState === undefined) {
                return currentState;
            }

            if (currentState instanceof ObservableMap) {
                return currentState.get(key);
            }

            return currentState[key];
        }, this.state);
    }
    observeState(state: {}) {
        const root: { [key: string]: any } = observable({});
        const extension: {
            [key: string]: any;
        } = traverse(state, (parent: { [key: string]: any }, key: string, path: string[]) => {
            if (isObservable(parent[key])) {
                return parent[key];
            } else if (isObject(parent[key])) {
                return observable(parent[key]);
            }

            return parent[key];
        });

        const extended = extendObservable(
            root,
            Object.keys(extension).reduce((root: { [key: string]: any }, key: string) => {
                const propertyDescriptor = Object.getOwnPropertyDescriptor(extension, key);
                if (propertyDescriptor && 'get' in propertyDescriptor) {
                    Object.defineProperty(root, key, propertyDescriptor);
                } else if (extension[key] instanceof ComputedClass) {
                    extension[key].getState = () => ({ state: extended, root: this.state });

                    root[key] = extension[key];
                } else if (isObservable(extension[key])) {
                    root[key] = observable.ref(extension[key]);
                } else {
                    root[key] = extension[key];
                }

                return root;
            }, {})
        );

        return extended;
    }
}

export default Model;
