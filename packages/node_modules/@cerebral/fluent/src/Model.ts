import {
  extractModuleProp,
  isObject,
  throwError,
  BaseModel
} from 'cerebral/internal'
import {
  BaseControllerClass,
  InstantiatedModuleObjectDefinition,
  Provider
} from 'cerebral'
import {
  observable,
  isObservable,
  createTransformer,
  extendObservable,
  ObservableMap,
  useStrict,
  computed,
} from 'mobx'
import { updateIn, traverse } from './utils'

function CreateStateProvider (state: any, devtools: any) {
  return Provider(state, {
    wrap: () => {
      return state
    },
    ignoreDefinition: true
  })
}

class Model extends BaseModel {
  constructor(controller: BaseControllerClass) {
    super(controller)
    useStrict(true)
    this.state = extractModuleProp(
      controller.module,
      'state',
      (state: any, module: any) => {
        return this.observeState(state)
      }
    )
    this.StateProvider = (devtools) => CreateStateProvider(this.state, devtools)
  }
  // Used by initial state changed
  set(path: string, value: any) {
    updateIn(this.state, path.split('.'), (parentState: {[key: string]: any}, key: string) => {
      parentState[key] = value
    })
  }
  get(path: string[]) {
    return path.reduce((currentState, key) => {
      if (currentState instanceof ObservableMap) {
        return currentState.get(key)
      }

      return currentState[key]
    }, this.state)
  }
  observeState(state: {}) {
    const root: {[key: string]: any} = observable({})
    const extension: {[key: string]: any} = traverse(state, (parent: {[key: string]: any}, key: string, path: string[]) => {
      if (typeof parent[key] === 'function') {
        return createTransformer(parent[key].bind(root))
      } else if (isObservable(parent[key])) {
        return parent[key]
      } else if (isObject(parent[key]) && Object.keys(parent[key]).length) {
        return observable(parent[key])
      } else if (isObject(parent[key])) {
        throwError(
          `You have an empty object in your state at "${path.join(
            '.'
          )}", you will need to define an ObservableMap`
        )
      }

      return parent[key]
    })

    return extendObservable(
      root,
      Object.keys(extension).reduce((root: {[key: string]: any}, key: string) => {
        if (!extension[key]) {
          return root
        }
        const propertyDescriptor = Object.getOwnPropertyDescriptor(extension, key)

        if (isObservable(extension[key])) {
          root[key] = observable.ref(extension[key])
        } else if (propertyDescriptor && 'get' in propertyDescriptor) {
          Object.defineProperty(
            root,
            key,
            propertyDescriptor
          )
        } else {
          root[key] = extension[key]
        }

        return root
      }, {})
    )
  }
}

export default Model
