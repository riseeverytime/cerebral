import {
  extractModuleProp,
  isObject,
  throwError,
  BaseModel
} from 'cerebral/internal'
import {
  BaseControllerClass,
  InstantiatedModuleObjectDefinition,
  Provider
} from 'cerebral'
import {
  observable,
  isObservable,
  isObservableMap,
  isComputed,
  extendObservable,
  ObservableMap,
  useStrict,
  computed,
} from 'mobx'
import {
  ComputedClass
} from './Computed'
import { updateIn, traverse } from './utils'

const mutationMethods: PropertyKey[] = [
  'concat',
  'pop',
  'push',
  'shift',
  'splice',
  'unshift',
]

const nonMutationObservableMapKeys: PropertyKey[] = [
  'has',
  'keys',
  'values',
  'entries',
  'isValidKey',
  '_hasMap',
  'forEach'
]

function cleanPath (state: any, key: PropertyKey, path: PropertyKey[]): PropertyKey[] {
  const pathCopy = path.concat(key)
  let isValid = false
  while (!isValid) {
   const value = pathCopy.reduce((currentState, pathKey) => {
     if (currentState === undefined) {
       return
     }
     if (isObservableMap(currentState)) {
       return currentState.get(pathKey.toString())
     }

     if (typeof currentState === 'object' && pathKey in currentState) {
       return currentState[pathKey]
     }

     return
   }, state)
   
   if (value === undefined) {
     pathCopy.splice(pathCopy.length - 2, 1)
   } else {
     isValid = true
   }
  }
 
 return pathCopy
}


function createValidator (state: any, execution: any, functionDetails: any, props: any, devtools: any) {
  let path: PropertyKey[] = []

  var validator = {
    get(target: any, key: PropertyKey): any {
      if (isObservableMap(target)) {
        switch (key) {
          case 'size':
            path = cleanPath(state, key, path)
            return target[key]
          case 'forEach':
            const originalFunc = target[key]
            return (cb: any) => {
              return target.keys().forEach((forEachKey, ...args: any[]) => {
                path = cleanPath(state, forEachKey, path)
                cb(new Proxy(target.get(forEachKey), validator), ...args)
              })
            } 
          case 'entries': {
            const originalFunc = target[key]

            return (...args: any[]) => {
              const value = originalFunc.apply(target, args)
              path = cleanPath(state, key, path)
              return value
            } 
          }
          case 'get': {
            const originalFunc = target[key]
            return (mapKey: string) => {
              path = cleanPath(state, mapKey, path)
              const value = originalFunc.call(target, mapKey)

              return new Proxy(value, validator)
            }
          }
          case 'delete': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData({
                  type: 'mutation',
                  method: 'unset',
                  args: [path.concat(args[0])]
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, key, path)
              return originalFunction.apply(target, args)
            }
          }
          case 'clear': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData({
                  type: 'mutation',
                  method: 'set',
                  args: [path, {}]
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, key, path)
              return originalFunction.apply(target, args)
            }    
          }
          case 'merge': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData({
                  type: 'mutation',
                  method: 'merge',
                  args: [path, args[0]]
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, key, path)
              return originalFunction.apply(target, args)
            }    
          }
          case  'replace':
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData({
                  type: 'mutation',
                  method: 'set',
                  args: [path, args[0]]
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, key, path)
              return originalFunction.apply(target, args)
            }
          case 'set': {
            const originalFunction = target[key]
            return (...args: any[]) => {
              devtools.sendExecutionData({
                  type: 'mutation',
                  method: 'set',
                  args: [path.concat(args[0]), args[1]]
                },
                execution,
                functionDetails,
                props
              )
              path = cleanPath(state, key, path)
              return originalFunction.apply(target, args)
            }
          }
          default:
            return (<any>target)[key]
        }
      } else  if (target[key] instanceof ComputedClass) {
        return target[key]
      } else if (typeof target[key] === 'object' && target[key] !== null) {
        path = cleanPath(state, key, path)
        return new Proxy(target[key], validator)
      } else {
         if (typeof target[key] === 'function' && mutationMethods.indexOf(key) >= 0) {
          const originalFunction = target[key]
          return (...args: any[]) => {
            devtools.sendExecutionData({
                type: 'mutation',
                method: key,
                args: [path, ...args]
              },
              execution,
              functionDetails,
              props
            )
            path = cleanPath(state, key, path)
            return originalFunction.apply(target, args)
          }
        }
        return target[key];
      }
    },
    set (target: any, key: PropertyKey, value: any) {
      path = cleanPath(state, key, path)
      devtools.sendExecutionData({
          type: 'mutation',
          method: 'set',
          args: [path, isObservable(value) ? value.value : value]
        },
        execution,
        functionDetails,
        props
      )

      return Reflect.set(target, key, value);
    }
  }

  return validator
}


function CreateStateProvider (state: any, devtools: any) {
  return Provider(state, {
    wrap: devtools ? (context: any) => {
      return new Proxy(state, createValidator(state, context.execution, context.functionDetails, context.props, devtools))
    } : false,
    ignoreDefinition: true
  })
}

class Model extends BaseModel {
  constructor(controller: BaseControllerClass) {
    super(controller)
    useStrict(true)
    this.state = extractModuleProp(
      controller.module,
      'state',
      (state: any, module: any) => {
        return this.observeState(state)
      }
    )
    this.StateProvider = (devtools) => CreateStateProvider(this.state, devtools)
  }
  // Used by initial state changed
  set(path: string, value: any) {
    updateIn(this.state, path.split('.'), (parentState: {[key: string]: any}, key: string) => {
      parentState[key] = value
    })
  }
  get(path: string[]) {
    if (!path) {
      return this.state
    }

    return path.reduce((currentState, key) => {
      if (currentState instanceof ObservableMap) {
        return currentState.get(key)
      }

      return currentState[key]
    }, this.state)
  }
  observeState(state: {}) {
    const root: {[key: string]: any} = observable({})
    const extension: {[key: string]: any} = traverse(state, (parent: {[key: string]: any}, key: string, path: string[]) => {
       if (isObservable(parent[key])) {
        return parent[key]
      } else if (isObject(parent[key]) && Object.keys(parent[key]).length) {
        return observable(parent[key])
      } else if (isObject(parent[key])) {
        throwError(
          `You have an empty object in your state at "${path.join(
            '.'
          )}", you will need to define an ObservableMap`
        )
      }

      return parent[key]
    })

    const extended = extendObservable(
      root,
      Object.keys(extension).reduce((root: {[key: string]: any}, key: string) => {
        if (extension[key] instanceof ComputedClass) {
          extension[key].getState = () => extended
  
          root[key] = extension[key]
        } else if (isObservable(extension[key])) {
          root[key] = observable.ref(extension[key])
        }  else {
          root[key] = extension[key]
        }

        return root
      }, {})
    )

    return extended;
  }
}

export default Model
