import {
  extractModuleProp,
  isObject,
  throwError,
  BaseModel
} from 'cerebral/internal'
import {
  BaseControllerClass,
  InstantiatedModuleObjectDefinition,
  Provider
} from 'cerebral'
import {
  observable,
  isObservable,
  isObservableMap,
  createTransformer,
  extendObservable,
  ObservableMap,
  useStrict,
  computed,
} from 'mobx'
import { updateIn, traverse } from './utils'

const mutationMethods: PropertyKey[] = [
  'concat',
  'pop',
  'push',
  'shift',
  'splice',
  'unshift',
]

function createValidator (execution: any, functionDetails: any, props: any, devtools: any) {
  const path: PropertyKey[] = []

  var validator = {
    get(target: any, key: PropertyKey): any {
      if (key === 'set' && isObservableMap(target)) {
        const originalFunction = target[key]
        return (...args: any[]) => {
          path.push(args[0])
          devtools.sendExecutionData({
              type: 'mutation',
              method: key,
              args: [path, args[1]]
            },
            execution,
            functionDetails,
            props
          )
          return originalFunction.apply(target, args)
        }
      } else if (typeof target[key] === 'object' && target[key] !== null) {
        if (!(key.toString()[0] === '_' && target.$mobx)) {
          path.push(key)
        }
        return new Proxy(target[key], validator)
      } else {
         if (typeof target[key] === 'function' && mutationMethods.indexOf(key) >= 0) {
          const originalFunction = target[key]
          return (...args: any[]) => {
            devtools.sendExecutionData({
                type: 'mutation',
                method: key,
                path: path,
                args: args
              },
              execution,
              functionDetails,
              props
            )
            return originalFunction.apply(target, args)
          }
        }
        return target[key];
      }
    },
    set (target: any, key: PropertyKey, value: any) {
      path.push(key)
      target[key] = value
      console.log({
        type: 'mutation',
          method: 'set',
          args: [path, isObservable(value) ? value.value : value]
      })
      devtools.sendExecutionData({
          type: 'mutation',
          method: 'set',
          args: [path, isObservable(value) ? value.value : value]
        },
        execution,
        functionDetails,
        props
      )
      return true
    }
  }

  return validator
}


function CreateStateProvider (state: any, devtools: any) {
  return Provider(state, {
    wrap: devtools ? (context: any) => {
      return new Proxy(state, createValidator(context.execution, context.functionDetails, context.props, devtools))
    } : false,
    ignoreDefinition: true
  })
}

class Model extends BaseModel {
  constructor(controller: BaseControllerClass) {
    super(controller)
    useStrict(true)
    this.state = extractModuleProp(
      controller.module,
      'state',
      (state: any, module: any) => {
        return this.observeState(state)
      }
    )
    this.StateProvider = (devtools) => CreateStateProvider(this.state, devtools)
  }
  // Used by initial state changed
  set(path: string, value: any) {
    updateIn(this.state, path.split('.'), (parentState: {[key: string]: any}, key: string) => {
      parentState[key] = value
    })
  }
  get(path: string[]) {
    if (!path) {
      return this.state
    }

    return path.reduce((currentState, key) => {
      if (currentState instanceof ObservableMap) {
        return currentState.get(key)
      }

      return currentState[key]
    }, this.state)
  }
  observeState(state: {}) {
    const root: {[key: string]: any} = observable({})
    const extension: {[key: string]: any} = traverse(state, (parent: {[key: string]: any}, key: string, path: string[]) => {
      if (typeof parent[key] === 'function') {
        return createTransformer(parent[key].bind(root))
      } else if (isObservable(parent[key])) {
        return parent[key]
      } else if (isObject(parent[key]) && Object.keys(parent[key]).length) {
        return observable(parent[key])
      } else if (isObject(parent[key])) {
        throwError(
          `You have an empty object in your state at "${path.join(
            '.'
          )}", you will need to define an ObservableMap`
        )
      }

      return parent[key]
    })

    return extendObservable(
      root,
      Object.keys(extension).reduce((root: {[key: string]: any}, key: string) => {
        if (!extension[key]) {
          return root
        }
        const propertyDescriptor = Object.getOwnPropertyDescriptor(extension, key)

        if (isObservable(extension[key])) {
          root[key] = observable.ref(extension[key])
        } else if (propertyDescriptor && 'get' in propertyDescriptor) {
          Object.defineProperty(
            root,
            key,
            propertyDescriptor
          )
        } else {
          root[key] = extension[key]
        }

        return root
      }, {})
    )
  }
}

export default Model
