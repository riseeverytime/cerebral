import {
  extractModuleProp,
  isObject,
  throwError,
  BaseModel
} from 'cerebral/internal'
import {
  BaseControllerClass,
  InstantiatedModuleObjectDefinition,
  Provider
} from 'cerebral'
import {
  observable,
  isObservable,
  isObservableMap,
  isComputed,
  extendObservable,
  ObservableMap,
  useStrict,
  computed,
} from 'mobx'
import {
  ComputedClass
} from './Computed'
import { updateIn, traverse } from './utils'

const mutationMethods: PropertyKey[] = [
  'concat',
  'pop',
  'push',
  'shift',
  'splice',
  'unshift',
]

function createValidator (execution: any, functionDetails: any, props: any, devtools: any) {
  let path: PropertyKey[] = []

  var validator = {
    get(target: any, key: PropertyKey): any {
      if (target[key] instanceof ComputedClass) {
        return target[key]
      } else if (key === 'get' && isObservableMap(target)) {
        const originalFunc = target[key]
        return (mapKey: string) => {
          path.push(mapKey)
          const value = originalFunc.call(target, mapKey)

          return new Proxy(value, validator)
        } 
      } else if (key === 'set' && isObservableMap(target)) {
        const originalFunction = target[key]
        return (...args: any[]) => {
          path.push(args[0])
          devtools.sendExecutionData({
              type: 'mutation',
              method: key,
              args: [path, args[1]]
            },
            execution,
            functionDetails,
            props
          )
          return originalFunction.apply(target, args)
        }
      } else if (typeof target[key] === 'object' && target[key] !== null) {
        path.push(key)
        return new Proxy(target[key], validator)
      } else {
         if (typeof target[key] === 'function' && mutationMethods.indexOf(key) >= 0) {
          const originalFunction = target[key]
          return (...args: any[]) => {
            devtools.sendExecutionData({
                type: 'mutation',
                method: key,
                args: [path, ...args]
              },
              execution,
              functionDetails,
              props
            )
            path = []
            return originalFunction.apply(target, args)
          }
        }
        return target[key];
      }
    },
    set (target: any, key: PropertyKey, value: any) {
      path.push(key)
      devtools.sendExecutionData({
          type: 'mutation',
          method: 'set',
          args: [path, isObservable(value) ? value.value : value]
        },
        execution,
        functionDetails,
        props
      )
      path = []

      return Reflect.set(target, key, value);
    }
  }

  return validator
}


function CreateStateProvider (state: any, devtools: any) {
  return Provider(state, {
    wrap: devtools ? (context: any) => {
      return new Proxy(state, createValidator(context.execution, context.functionDetails, context.props, devtools))
    } : false,
    ignoreDefinition: true
  })
}

class Model extends BaseModel {
  constructor(controller: BaseControllerClass) {
    super(controller)
    useStrict(true)
    this.state = extractModuleProp(
      controller.module,
      'state',
      (state: any, module: any) => {
        return this.observeState(state)
      }
    )
    this.StateProvider = (devtools) => CreateStateProvider(this.state, devtools)
  }
  // Used by initial state changed
  set(path: string, value: any) {
    updateIn(this.state, path.split('.'), (parentState: {[key: string]: any}, key: string) => {
      parentState[key] = value
    })
  }
  get(path: string[]) {
    if (!path) {
      return this.state
    }

    return path.reduce((currentState, key) => {
      if (currentState instanceof ObservableMap) {
        return currentState.get(key)
      }

      return currentState[key]
    }, this.state)
  }
  observeState(state: {}) {
    const root: {[key: string]: any} = observable({})
    const extension: {[key: string]: any} = traverse(state, (parent: {[key: string]: any}, key: string, path: string[]) => {
       if (isObservable(parent[key])) {
        return parent[key]
      } else if (isObject(parent[key]) && Object.keys(parent[key]).length) {
        return observable(parent[key])
      } else if (isObject(parent[key])) {
        throwError(
          `You have an empty object in your state at "${path.join(
            '.'
          )}", you will need to define an ObservableMap`
        )
      }

      return parent[key]
    })

    const extended = extendObservable(
      root,
      Object.keys(extension).reduce((root: {[key: string]: any}, key: string) => {
        if (extension[key] instanceof ComputedClass) {
          const originalCallback = extension[key].callback
          extension[key].callback = () => originalCallback.call(extended)
  
          root[key] = extension[key]
        } else if (isObservable(extension[key])) {
          root[key] = observable.ref(extension[key])
        }  else {
          root[key] = extension[key]
        }

        return root
      }, {})
    )

    return extended;
  }
}

export default Model
