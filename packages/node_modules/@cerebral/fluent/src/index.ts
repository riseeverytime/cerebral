import { observable, untracked, transaction, extras, ObservableMap as MobxObservableMap } from 'mobx'
import { BaseControllerClass, ModuleClass, InstantiatedModuleObjectDefinition, ControllerOptions } from 'cerebral'
import { extractModuleProp, getModule, throwError } from 'cerebral/internal'
import { updateIn } from './utils'
import Model from './Model'
// import Hoc from './Hoc'
import { sequenceFactory, SequenceBuilder } from 'function-tree/fluent'
// import connectFactory, { decoratorFactory } from './connect'
import { ModuleSignals } from './types'

// export { default as Container } from './Container'
// export const connect = connectFactory(Hoc)
// export const decorator = decoratorFactory(Hoc)

export type ObservableMap<Type> = MobxObservableMap<Type>
export function ObservableMap<Type> (values: {[key: string]: Type}): MobxObservableMap<Type> {
  return new MobxObservableMap(values)
}
export const Signal = sequenceFactory

// mobx uses extra fields in modules and therefore needs to declare it's own `Module` constructor.
export { Module } from 'cerebral'


class FluentController<State = {}, Signals = {}> extends BaseControllerClass {
  state: State
  signals: Signals
  constructor(rootModule: ModuleClass, options: ControllerOptions) {
    super(rootModule, options, {
      executeBranchWrapper: (cb: () => void) => {
        extras.allowStateChanges(true, () => untracked(() => transaction(cb)))
      },
    })

    this.state = this.model.state
    this.signals = extractModuleProp(
      this.module,
      'signals',
      (signals: ModuleSignals, module) => {
        return Object.keys(signals).reduce((runableSignals: ModuleSignals, key: string) => {
          runableSignals[key] = signals[key]

          return runableSignals
        }, {})
      }
    )
  }
  addModule(path: string, module: ModuleClass) {
    const pathArray = path.split('.')
    const moduleKey = pathArray.pop()
    if (!moduleKey) {
      return throwError('Can not find module path to add module')
    }
    const parentModule = getModule(pathArray, this.module)
    const newModule = module.create(this, pathArray.concat(moduleKey))

    if (!parentModule.modules || !parentModule.modules[moduleKey]) {
      return throwError('Can not find module path to add module')
    }

    parentModule.modules[moduleKey] = newModule

    if (newModule.providers) {
      Object.assign(this.contextProviders, newModule.providers)
    }

    updateIn(this.state, pathArray.concat(moduleKey), (parentState: {[key: string]: any}, key: string) => {
      parentState[key] = observable(newModule.state)
    })
    updateIn(this.signals, pathArray.concat(moduleKey), (parentState: {[key: string]: any}, key: string) => {
      parentState[key] = Object.keys(
        newModule.signals
      ).reduce((signals: ModuleSignals, key: string) => {
        signals[key] = newModule.signals[key]

        return signals
      }, {})
    })

    this.emit('moduleAdded', path.split('.'), newModule)
  }
  removeModule(path: string) {
    if (!path) {
      console.warn('Controller.removeModule requires a Module Path')
      return null
    }

    const pathArray = path.split('.')
    const moduleKey = pathArray.pop()
    const parentModule = getModule(pathArray, this.module)

    if (!moduleKey || !parentModule || !parentModule.modules) {
      return throwError('Module you are trying to remove does not exist')
    }

    const module = parentModule.modules[moduleKey]

    if (module.providers) {
      Object.keys(module.providers).forEach(provider => {
        delete this.contextProviders[provider]
      })
    }

    delete parentModule.modules[moduleKey]
    updateIn(this.state, pathArray.concat(moduleKey), (parentState: {[key: string]: any}) => {
      delete parentState[moduleKey]
    })
    updateIn(this.signals, pathArray.concat(moduleKey), (parentSignals: ModuleSignals ) => {
      delete parentSignals[moduleKey]
    })

    this.emit('moduleRemoved', path, module)
  }
}

export function Controller(rootModule: ModuleClass, options: ControllerOptions = {}) {
  options.Model = Model

  return new FluentController(rootModule, options)
}
