import { observable, untracked, transaction, extras, ObservableMap as MobxObservableMap } from 'mobx';
import { BaseControllerClass, ModuleClass, InstantiatedModuleObjectDefinition, ControllerOptions } from 'cerebral';
import { extractModuleProp, getModule, throwError } from 'cerebral/internal';
import { updateIn } from './utils';
import Model from './Model';
import Hoc from './Hoc'
import { sequenceFactory, SequenceBuilder } from 'function-tree/fluent';

export { default as connect, ConnectFactory } from './connect'

export { sequenceFactory } from 'function-tree/fluent';

export { default as Container } from './Container'

export type ObservableMap<Type> = MobxObservableMap<Type>;
export function ObservableMap<Type>(values: { [key: string]: Type }): MobxObservableMap<Type> {
	return new MobxObservableMap(values);
}

/*
interface ErrorClass {
  new(...args: any[]): any 
}

export interface FluentModuleDefintion<State, Signals> {
  state?: State
  signals?: Signals
  modules?: {
    [submodule: string]: ModuleClass
  }
  catch?: [ ErrorClass, SequenceBuilder ][]
  providers?: {
    [providerName: string]: any
  }
}

export declare function Module<State, Signals>(definition: FluentModuleDefintion<State, Signals>): ModuleClass
*/

// mobx uses extra fields in modules and therefore needs to declare it's own `Module` constructor.
export { Module } from 'cerebral';


export function Sequence<Context, Props, Output = Props>(
	arg: (props: SequenceBuilder<Context, Props>) => SequenceBuilder<Context, Output>
): (props: Props) => Output {
	return sequenceFactory<Context, Props>(arg as any) as any;
}

export class FluentController<State = {}, Signals = {}> extends BaseControllerClass {
	state: State;
	signals: Signals;
	devtools: any
	constructor(rootModule: ModuleClass, options: ControllerOptions) {
		super(rootModule, options, {
			executeBranchWrapper: (cb: () => void) => {
				extras.allowStateChanges(true, () => untracked(() => transaction(cb)));
			}
		});

		this.state = this.model.state;
		this.signals = extractModuleProp(this.module, 'signals', (signals: any, module: any) => {
			return Object.keys(signals).reduce((runableSignals: any, key: string) => {
				if ('run' in signals[key]) {
					runableSignals[key] = signals[key].run;
				} else {
					runableSignals[key] = signals[key];
				}

				return runableSignals;
			}, {});
		});
	}
	addModule(path: string, module: ModuleClass) {
		const pathArray = path.split('.');
		const moduleKey = pathArray.pop();
		if (!moduleKey) {
			return throwError('Can not find module path to add module');
		}
		const parentModule = getModule(pathArray, this.module);
		const newModule = module.create(this, pathArray.concat(moduleKey));

		if (!parentModule.modules || !parentModule.modules[moduleKey]) {
			return throwError('Can not find module path to add module');
		}

		parentModule.modules[moduleKey] = newModule;

		if (newModule.providers) {
			Object.assign(this.contextProviders, newModule.providers);
		}

		updateIn(this.state, pathArray.concat(moduleKey), (parentState: { [key: string]: any }, key: string) => {
			parentState[key] = observable(newModule.state);
		});
		updateIn(this.signals, pathArray.concat(moduleKey), (parentState: { [key: string]: any }, key: string) => {
			parentState[key] = Object.keys(newModule.signals).reduce((signals: any, key: string) => {
				signals[key] = newModule.signals[key];

				return signals;
			}, {});
		});

		this.emit('moduleAdded', path.split('.'), newModule);
	}
	removeModule(path: string) {
		if (!path) {
			console.warn('Controller.removeModule requires a Module Path');
			return null;
		}

		const pathArray = path.split('.');
		const moduleKey = pathArray.pop();
		const parentModule = getModule(pathArray, this.module);

		if (!moduleKey || !parentModule || !parentModule.modules) {
			return throwError('Module you are trying to remove does not exist');
		}

		const module = parentModule.modules[moduleKey];

		if (module.providers) {
			Object.keys(module.providers).forEach(provider => {
				delete this.contextProviders[provider];
			});
		}

		delete parentModule.modules[moduleKey];
		updateIn(this.state, pathArray.concat(moduleKey), (parentState: { [key: string]: any }) => {
			delete parentState[moduleKey];
		});
		updateIn(this.signals, pathArray.concat(moduleKey), (parentSignals: any) => {
			delete parentSignals[moduleKey];
		});

		this.emit('moduleRemoved', path, module);
	}
}

export function Controller<State = {}, Signals = {}>(rootModule: ModuleClass, options: ControllerOptions = {}) {
	options.Model = Model;

	return new FluentController<State, Signals>(rootModule, options);
}
