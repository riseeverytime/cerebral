/* eslint-env mocha */
import { Controller, Module, ObservableMap, Sequence, Signal, ComputedValue, Computed } from './';
import View from './View';
import { autorun } from 'mobx';
import * as assert from 'assert';

describe('Fluent', () => {
	it('should instantiate with initial state', () => {
		type State = {
			foo: string;
		};
		const rootModule = Module<State>({
			state: {
				foo: 'bar'
			}
		});
		const controller = Controller(rootModule);

		assert.deepEqual(controller.state, { foo: 'bar' });
	});
	it('should instantiate with observable maps', () => {
		type State = {
			map: ObservableMap<string>;
		};
		const rootModule = Module<State>({
			state: {
				map: ObservableMap({
					foo: 'bar'
				})
			}
		});
		const controller = Controller<State>(rootModule);

		assert.deepEqual(controller.state.map.get('foo'), 'bar');
	});

	it('should throw when empty object', () => {
		const rootModule = Module({
			state: {
				map: {}
			}
		});
		assert.throws(() => {
			Controller(rootModule);
		});
	});
	it('should throw when trying to mutate state outside actions', () => {
		type State = {
			foo: string;
		};
		const rootModule = Module<State>({
			state: {
				foo: 'bar'
			}
		});
		const controller = Controller<State>(rootModule);

		autorun(() => {
			return controller.state.foo;
		});

		assert.throws(() => {
			controller.state.foo = 'bar2';
		});
	});

	it('should allow state changes in actions', () => {
		type State = {
			foo: string;
		};
		type Signals = {
			test: (props: { foo: string }) => void;
		};
		type Context = {
			state: State;
		};

		const sequence = Sequence<
			Context,
			{
				foo: string;
			}
		>(s => s.action(function test({ state, props }) {
			state.foo = 'bar2'
		}));

		const rootModule = Module<State, Signals>({
			state: {
				foo: 'bar'
			},
			signals: {
				test: sequence
			}
		});
		const controller = Controller<State, Signals>(rootModule);

		controller.signals.test({
			foo: 'bar'
		});

		assert.equal(controller.state.foo, 'bar2');
	});

  it('should allow computed', () => {
		type State = {
			foo: string,
			test: ComputedValue<string>
		}
		type Signals = {
			test: Signal
		}
		type Context = {
			state: State
		}
		let hasUpdated = 0
		const getter = function getter (this: State) {
			return this.foo.toUpperCase()
		}
    const rootModule = Module<State, Signals>({
      state: {
				foo: 'bar',
				test: Computed(getter)
			},
			signals: {
				test: Sequence<Context, void>(s => s.action(function test ({ state }) {
					state.foo = 'bar2'
				}))
			}
    })
		const controller = Controller<State, Signals>(rootModule)
		
		autorun(() => {
			controller.state.test.get()
			hasUpdated++
		})

		assert.equal(controller.state.test.get(), 'BAR')
		controller.signals.test()
		assert.equal(hasUpdated, 2)
  })
  it('should work with fluent api', () => {
		type State = {
			foo: string
		}
		type Signals = {
			test: (props?: void) => void
		}
		type Context = {
			state: State
		}
		const sequence = Sequence<Context, void>(s =>
			s.action(function testAction({ state }) {
				state.foo = 'bar2'
			})
		)
    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
      },
      signals: {
        test: sequence
      },
    })
    const controller = Controller<State, Signals>(rootModule)
    controller.signals.test()
    assert.equal(controller.state.foo, 'bar2')
  })
	it('should send debugging data on mutation methods', () => {
		type State = {
			set: string,
			push: string[],
			pop: string[],
			shift: string[],
			splice: string[],
			unshift: string[],
			observableMapSet: ObservableMap<string>
		}
		type Signals = {
			test: Signal
		}
		type Context = {
			state: State
		}
		let actionCount = 0
		const sequence = Sequence<Context, void>(s => s
			.action(function test({ state }) {
				state.set = 'bar2'
			})
			.action(function test({ state }) {
				state.push.push('bar2')
			})
			.action(function test({ state }) {
				state.pop.pop()
			})
			.action(function test({ state }) {
				state.shift.shift()
			})
			.action(function test({ state }) {
				state.splice.splice(1, 0, 'baz')
			})
			.action(function test({ state }) {
				state.unshift.unshift('bar')
			})
			.action(function test({ state }) {
				state.observableMapSet.set('foo', 'bar')
			})
		)
    const rootModule = Module<State, Signals>({
      state: {
				set: 'foo',
				push: [],
				pop: ['foo'],
				shift: ['foo'],
				splice: ['foo', 'bar'],
				unshift: ['foo'],
				observableMapSet: ObservableMap({})
      },
      signals: {
        test: sequence
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() { },
				updateComponentsMap() {},
				sendExecutionData(data: any) {
					switch (actionCount) {
						case 0:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'set',
								args: [['set'], 'bar2']
							})
							break
						case 1:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'push',
								args: [['push'], 'bar2']
							})
							break
						case 2:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'pop',
								args: [['pop']]
							})
							break
						case 3:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'shift',
								args: [['shift']]
							})
							break
						case 4:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'splice',
								args: [['splice'], 1, 0, 'baz']
							})
							break
						case 5:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'unshift',
								args: [['unshift'], 'bar']
							})
							break
						case 6:
							assert.deepEqual(data, {
								type: 'mutation',
								method: 'set',
								args: [['observableMapSet', 'foo'], 'bar']
							})
							break
					}
					actionCount++
				}
      },
    })

    controller.signals.test()
		assert.equal(controller.state.set, 'bar2')
		assert.equal(controller.state.push[0], 'bar2')
		assert.equal(controller.state.pop.length, 0)
		assert.equal(controller.state.shift.length, 0)
		assert.equal(controller.state.splice.join('.'), 'foo.baz.bar')
		assert.equal(controller.state.unshift[0], 'bar')
		assert.equal(controller.state.observableMapSet.get('foo'), 'bar')
		assert.equal(actionCount, 7)
	})
	it('should update view on state changes', () => {
		type State = {
			foo: string;
		};
		type Signals = {
			test: (props: { foo: string }) => void;
		};
		type Context = {
			state: State;
		};
	
		let hasUpdated = false
		const sequence = Sequence<
			Context,
			{
				foo: string;
			}
		>(s => s.action(function test({ state, props }) {
			state.foo = 'bar2'
		}));
	
		const rootModule = Module<State, Signals>({
			state: {
				foo: 'bar'
			},
			signals: {
				test: sequence
			}
		});
		const controller = Controller<State, Signals>(rootModule);
		const view = new View ({
			controller,
			onUpdate() {
				hasUpdated = true
			},
			props: {},
			dependencies() {
				return {
					foo: controller.state.foo
				}
			},
			displayName: 'woo'
		})
		view.mount()
	
		controller.signals.test({
			foo: 'bar'
		});
	
		assert.equal(controller.state.foo, 'bar2');
		assert.equal(hasUpdated, true);
	});
	it('should handle nested map property', () => {
		type State = {
			observableMapSet: ObservableMap<{
				foo: string	
			}>
		}
		type Signals = {
			test: Signal
		}
		type Context = {
			state: State
		}
		let actionCount = 0
		const sequence = Sequence<Context, void>(s => s
			.action(function test({ state }) {
				const item = state.observableMapSet.get('item')
				if (item) {
					item.foo = 'string2'
				}
			})
		)
    const rootModule = Module<State, Signals>({
      state: {
				observableMapSet: ObservableMap({
					'item': {
						foo: 'string'
					}
				})
      },
      signals: {
        test: sequence
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() { },
				updateComponentsMap() {},
				sendExecutionData(data: any) {
					assert.deepEqual(data, {
						type: 'mutation',
						method: 'set',
						args: [['observableMapSet', 'item', 'foo'], 'string2']
					})
					actionCount++
				}
      },
    })

    controller.signals.test()

		const item = controller.state.observableMapSet.get('item')
		if (item) {
			assert.equal(item.foo, 'string2')
		}
	})
});