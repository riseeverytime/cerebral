/* eslint-env mocha */
import { Controller, Module, ObservableMap, Signal } from './'
import { autorun } from 'mobx'
import * as assert from 'assert'

describe('Fluent', () => {
  it('should instantiate with initial state', () => {
    type State = {
      foo: string
    }
    const rootModule = Module<State>({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    assert.deepEqual(controller.state, { foo: 'bar' })
  })
  it('should instantiate with observable maps', () => {
    type State = {
      map: ObservableMap<{ foo: string }>
    }
    const rootModule = Module<State>({
      state: {
        map: ObservableMap({
          foo: '123'
        })
      },
    })
    const controller = Controller(rootModule)

    assert.deepEqual(controller.state.map.get('foo'), 'bar')
  })
    /*
  it('should throw when empty object', () => {
    const rootModule = Module({
      state: {
        map: {},
      },
    })
    assert.throws(() => {
      Controller(rootModule)
    })
  })
  it('should throw when trying to mutate state outside actions', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
    })
    const controller = Controller(rootModule)

    autorun(() => {
      return controller.state.foo
    })

    assert.throws(() => {
      controller.state.foo = 'bar2'
    })
  })
  it('should allow state changes in actions', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        test: function test({ state }) {
          state.foo = 'bar2'
        },
      },
    })
    const controller = Controller(rootModule)

    controller.signals.test()

    assert.equal(controller.state.foo, 'bar2')
  })
  it('should allow computed', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      computed: {
        test(state) {
          return state.foo.toUpperCase()
        },
      },
    })
    const controller = Controller(rootModule)

    assert.equal(controller.state.test, 'BAR')
  })
  it('should work with fluent api', () => {
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        test: Signal(s =>
          s.action(function testAction({ state }) {
            state.foo = 'bar2'
          })
        ),
      },
    })
    const controller = Controller(rootModule)
    controller.signals.test()
    assert.equal(controller.state.foo, 'bar2')
  })
  /*
  it('should send debugging data on mutations', () => {
    let hasSentData = false
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        test: function test({ state }) {
          state.foo = 'bar2'
        },
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        init() {},
        send(data) {
          hasSentData = true
          assert.equal(data, 'foo')
        },
        updateComponentsMap() {},
      },
    })

    controller.signals.test()
    assert.ok(hasSentData)
  })
  */
})
