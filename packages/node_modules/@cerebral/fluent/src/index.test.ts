/* eslint-env mocha */
import { Controller, Module, ObservableMap, Sequence } from './';
import { autorun } from 'mobx';
import * as assert from 'assert';

describe('Fluent', () => {
	it('should instantiate with initial state', () => {
		type State = {
			foo: string;
		};
		const rootModule = Module<State>({
			state: {
				foo: 'bar'
			}
		});
		const controller = Controller(rootModule);

		assert.deepEqual(controller.state, { foo: 'bar' });
	});
	it('should instantiate with observable maps', () => {
		type State = {
			map: ObservableMap<string>;
		};
		const rootModule = Module<State>({
			state: {
				map: ObservableMap({
					foo: 'bar'
				})
			}
		});
		const controller = Controller<State>(rootModule);

		assert.deepEqual(controller.state.map.get('foo'), 'bar');
	});

	it('should throw when empty object', () => {
		const rootModule = Module({
			state: {
				map: {}
			}
		});
		assert.throws(() => {
			Controller(rootModule);
		});
	});
	it('should throw when trying to mutate state outside actions', () => {
		type State = {
			foo: string;
		};
		const rootModule = Module<State>({
			state: {
				foo: 'bar'
			}
		});
		const controller = Controller<State>(rootModule);

		autorun(() => {
			return controller.state.foo;
		});

		assert.throws(() => {
			controller.state.foo = 'bar2';
		});
	});

	it('should allow state changes in actions', () => {
		type State = {
			foo: string;
		};
		type Signals = {
			test: (props: { foo: string }) => void;
		};
		type Context = {
			state: State;
		};

		const sequence = Sequence<
			Context,
			{
				foo: string;
			}
		>(s => s.action(function test({ state, props }) {
			state.foo = 'bar2'
		}));

		const rootModule = Module<State, Signals>({
			state: {
				foo: 'bar'
			},
			signals: {
				test: sequence
			}
		});
		const controller = Controller<State, Signals>(rootModule);

		controller.signals.test({
			foo: 'bar'
		});

		assert.equal(controller.state.foo, 'bar2');
	});

  it('should allow computed', () => {
		type State = {
			foo: string,
			test: string
		}
    const rootModule = Module<State>({
      state: {
				foo: 'bar',
				get test() {
          return this.foo.toUpperCase()
        },
      }
    })
    const controller = Controller<State>(rootModule)

    assert.equal(controller.state.test, 'BAR')
  })
  it('should work with fluent api', () => {
		type State = {
			foo: string
		}
		type Signals = {
			test: (props: {}) => void
		}
		type Context = {
			state: State
		}
		const sequence = Sequence<Context, {}>(s =>
			s.action(function testAction({ state }) {
				state.foo = 'bar2'
			})
		)
    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
      },
      signals: {
        test: sequence
      },
    })
    const controller = Controller<State, Signals>(rootModule)
    controller.signals.test({})
    assert.equal(controller.state.foo, 'bar2')
  })
	it('should send debugging data on mutation methods', () => {
		type State = {
			set: string,
			push: string[],
			pop: string[],
			shift: string[],
			splice: string[],
			unshift: string[],
			observableMapSet: ObservableMap<string>
		}
		type Signals = {
			test: (props: {}) => void
		}
		type Context = {
			state: State
		}
		let actionCount = 0
		const sequence = Sequence<Context, {}>(s => s
			.action(function test({ state }) {
				state.set = 'bar2'
			})
			.action(function test({ state }) {
				state.push.push('bar2')
			})
			.action(function test({ state }) {
				state.pop.pop()
			})
			.action(function test({ state }) {
				state.shift.shift()
			})
			.action(function test({ state }) {
				state.splice.splice(1, 0, 'baz')
			})
			.action(function test({ state }) {
				state.unshift.unshift('bar')
			})
			.action(function test({ state }) {
				state.observableMapSet.set('foo', 'bar')
			})
		)
    const rootModule = Module<State, Signals>({
      state: {
				set: 'foo',
				push: [],
				pop: ['foo'],
				shift: ['foo'],
				splice: ['foo', 'bar'],
				unshift: ['foo'],
				observableMapSet: ObservableMap({})
      },
      signals: {
        test: sequence
      },
    })
    const controller = Controller<State, Signals>(rootModule, {
      devtools: {
        init() {},
        send() { },
				updateComponentsMap() {},
				sendExecutionData(data: any) {
					switch (actionCount) {
						case 0:
							assert.deepEqual(data.debuggerData, {
								method: 'set',
								path: ['set'],
								args: ['bar2']
							})
							break
						case 1:
							assert.deepEqual(data.debuggerData, {
								method: 'push',
								path: ['push'],
								args: ['bar2']
							})
							break
						case 2:
							assert.deepEqual(data.debuggerData, {
								method: 'pop',
								path: ['pop'],
								args: []
							})
							break
						case 3:
							assert.deepEqual(data.debuggerData, {
								method: 'shift',
								path: ['shift'],
								args: []
							})
							break
						case 4:
							assert.deepEqual(data.debuggerData, {
								method: 'splice',
								path: ['splice'],
								args: [1, 0, 'baz']
							})
							break
						case 5:
							assert.deepEqual(data.debuggerData, {
								method: 'unshift',
								path: ['unshift'],
								args: ['bar']
							})
							break
						case 6:
							assert.deepEqual(data.debuggerData, {
								method: 'set',
								path: ['observableMapSet', 'foo'],
								args: ['bar']
							})
							break
					}
					actionCount++
				}
      },
    })

    controller.signals.test({})
		assert.equal(controller.state.set, 'bar2')
		assert.equal(controller.state.push[0], 'bar2')
		assert.equal(controller.state.pop.length, 0)
		assert.equal(controller.state.shift.length, 0)
		assert.equal(controller.state.splice.join('.'), 'foo.baz.bar')
		assert.equal(controller.state.unshift[0], 'bar')
		assert.equal(controller.state.observableMapSet.get('foo'), 'bar')
		assert.equal(actionCount, 7)
  })
});
