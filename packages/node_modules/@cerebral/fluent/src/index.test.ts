/* eslint-env mocha */
import { Controller, Module, ObservableMap, Sequence } from './';
import { autorun } from 'mobx';
import * as assert from 'assert';

describe('Fluent', () => {
	it('should instantiate with initial state', () => {
		type State = {
			foo: string;
		};
		const rootModule = Module<State>({
			state: {
				foo: 'bar'
			}
		});
		const controller = Controller(rootModule);

		assert.deepEqual(controller.state, { foo: 'bar' });
	});
	it('should instantiate with observable maps', () => {
		type State = {
			map: ObservableMap<string>;
		};
		const rootModule = Module<State>({
			state: {
				map: ObservableMap({
					foo: 'bar'
				})
			}
		});
		const controller = Controller<State>(rootModule);

		assert.deepEqual(controller.state.map.get('foo'), 'bar');
	});

	it('should throw when empty object', () => {
		const rootModule = Module({
			state: {
				map: {}
			}
		});
		assert.throws(() => {
			Controller(rootModule);
		});
	});
	it('should throw when trying to mutate state outside actions', () => {
		type State = {
			foo: string;
		};
		const rootModule = Module<State>({
			state: {
				foo: 'bar'
			}
		});
		const controller = Controller<State>(rootModule);

		autorun(() => {
			return controller.state.foo;
		});

		assert.throws(() => {
			controller.state.foo = 'bar2';
		});
	});

	it('should allow state changes in actions', () => {
		type State = {
			foo: string;
		};
		type Signals = {
			test: (props: { foo: string }) => void;
		};
		type Context = {
			state: State;
		};

		const sequence = Sequence<
			Context,
			{
				foo: string;
			}
		>(s => s.action(function test({ state, props }) {
			state.foo = 'bar2'
		}));

		const rootModule = Module<State, Signals>({
			state: {
				foo: 'bar'
			},
			signals: {
				test: sequence
			}
		});
		const controller = Controller<State, Signals>(rootModule);

			console.log(controller.signals.test)
		controller.signals.test({
			foo: 'bar'
		});

		assert.equal(controller.state.foo, 'bar2');
	});

  it('should allow computed', () => {
		type State = {
			foo: string,
			test: string
		}
    const rootModule = Module<State>({
      state: {
				foo: 'bar',
				get test() {
          return this.foo.toUpperCase()
        },
      }
    })
    const controller = Controller<State>(rootModule)

    assert.equal(controller.state.test, 'BAR')
  })
  it('should work with fluent api', () => {
		type State = {
			foo: string
		}
		type Signals = {
			test: (props: {}) => void
		}
		type Context = {
			state: State
		}
		const sequence = Sequence<Context, {}>(s =>
			s.action(function testAction({ state }) {
				state.foo = 'bar2'
			})
		)
    const rootModule = Module<State, Signals>({
      state: {
        foo: 'bar',
      },
      signals: {
        test: sequence
      },
    })
    const controller = Controller<State, Signals>(rootModule)
    controller.signals.test({})
    assert.equal(controller.state.foo, 'bar2')
  })
  /*
  it('should send debugging data on mutations', () => {
    let hasSentData = false
    const rootModule = Module({
      state: {
        foo: 'bar',
      },
      signals: {
        test: function test({ state }) {
          state.foo = 'bar2'
        },
      },
    })
    const controller = Controller(rootModule, {
      devtools: {
        init() {},
        send(data) {
          hasSentData = true
          assert.equal(data, 'foo')
        },
        updateComponentsMap() {},
      },
    })

    controller.signals.test()
    assert.ok(hasSentData)
  })
  */
});
