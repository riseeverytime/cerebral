import {
  extractModuleProp,
  BaseModel,
  isObject,
  throwError,
} from 'cerebral/internal'
import {
  observable,
  isObservable,
  createTransformer,
  extendObservable,
  ObservableMap,
  useStrict,
  computed,
} from 'mobx'
import { updateIn, traverse } from './utils'

class Model extends BaseModel {
  constructor(controller) {
    super(controller)
    useStrict(true)
    this.state = extractModuleProp(
      controller.module,
      'state',
      (state, module, path) => {
        console.log(path)
        const newState = this.observeState(state, path)

        if (module.computed) {
          Object.keys(module.computed).forEach(key => {
            const computedInstance = computed(
              module.computed[key].bind(null, newState)
            )
            Object.defineProperty(newState, key, {
              get: computedInstance.get.bind(computedInstance),
            })
          })
        }

        return newState
      }
    )
    this.StateProvider = () => this.state
  }
  // Used by initial state changed
  set(path, value) {
    updateIn(this.state, path.split('.'), (parentState, key) => {
      parentState[key] = value
    })
  }
  get(path) {
    return path.reduce((currentState, key) => {
      if (currentState instanceof ObservableMap) {
        return currentState.get(key)
      }

      return currentState[key]
    }, this.state)
  }
  observeState(state) {
    const root = observable({})
    const extension = traverse(state, (parent, key, path) => {
      if (typeof parent[key] === 'function') {
        return createTransformer(parent[key].bind(root))
      } else if (isObservable(parent[key])) {
        return parent[key]
      } else if (isObject(parent[key]) && Object.keys(parent[key]).length) {
        return observable(parent[key])
      } else if (isObject(parent[key])) {
        throwError(
          `You have an empty object in your state at "${path.join(
            '.'
          )}", you will need to define an ObservableMap`
        )
      }

      return parent[key]
    })

    return extendObservable(
      root,
      Object.keys(extension).reduce((root, key) => {
        if (isObservable(extension[key])) {
          root[key] = observable.ref(extension[key])
        } else if ('get' in Object.getOwnPropertyDescriptor(extension, key)) {
          Object.defineProperty(
            root,
            key,
            Object.getOwnPropertyDescriptor(extension, key)
          )
        } else {
          root[key] = extension[key]
        }

        return root
      }, {})
    )
  }
}

export default Model
