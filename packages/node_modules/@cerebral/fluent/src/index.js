import { observable, untracked, transaction, extras } from 'mobx'
import { sequenceFactory } from 'function-tree/fluent'
import { BaseController } from 'cerebral'
import { extractModuleProp } from 'cerebral/internal'
import { updateIn, getModule } from './utils'
import Model from './Model'
import Hoc from './Hoc'
import connectFactory, { decoratorFactory } from './connect'

export { default as Container } from './Container'
export const connect = connectFactory(Hoc)
export const decorator = decoratorFactory(Hoc)
export const ObservableMap = values => observable.map(values)
export const Signal = sequence => {
  return sequenceFactory(sequence)
}

// mobx uses extra fields in modules and therefore needs to declare it's own `Module` constructor.
export { Module } from 'cerebral'

class FluentController extends BaseController {
  constructor(rootModule, options) {
    super(rootModule, options, {
      executeBranchWrapper: cb => {
        extras.allowStateChanges(true, () => untracked(() => transaction(cb)))
      },
    })

    this.state = this.model.state
    this.signals = extractModuleProp(
      this.module,
      'signals',
      (signals, module) => {
        return Object.keys(signals).reduce((runableSignals, key) => {
          if (signals[key].run) {
            runableSignals[key] = signals[key].run
          } else {
            runableSignals[key] = signals[key]
          }

          return runableSignals
        }, {})
      }
    )
  }
  addModule(path, module) {
    const pathArray = path.split('.')
    const moduleKey = pathArray.pop()
    const parentModule = getModule(pathArray, this.module)
    const newModule = module.create(this, pathArray.concat(moduleKey))
    parentModule.modules[moduleKey] = newModule

    if (newModule.providers) {
      Object.assign(this.contextProviders, newModule.providers)
    }

    updateIn(this.state, pathArray.concat(moduleKey), (parentState, key) => {
      parentState[key] = observable(newModule.state)
    })
    updateIn(this.signals, pathArray.concat(moduleKey), (parentState, key) => {
      parentState[key] = Object.keys(
        newModule.signals
      ).reduce((signals, key) => {
        signals[key] = newModule.signals[key].run

        return signals
      }, {})
    })

    this.emit('moduleAdded', path.split('.'), newModule)
  }
  removeModule(path) {
    if (!path) {
      console.warn('Controller.removeModule requires a Module Path')
      return null
    }

    const pathArray = path.split('.')
    const moduleKey = pathArray.pop()
    const parentModule = getModule(pathArray, this.module)

    const module = parentModule.modules[moduleKey]

    if (module.providers) {
      Object.keys(module.providers).forEach(provider => {
        delete this.contextProviders[provider]
      })
    }

    delete parentModule.modules[moduleKey]
    updateIn(this.state, pathArray.concat(moduleKey), parentState => {
      delete parentState[moduleKey]
    })
    updateIn(this.signals, pathArray.concat(moduleKey), parentSignals => {
      delete parentSignals[moduleKey]
    })

    this.emit('moduleRemoved', path, module)
  }
}

export function Controller(rootModule, options = {}) {
  options.Model = Model

  return new FluentController(rootModule, options)
}
