/*
import {
  observable,
  untracked,
  useStrict,
  transaction,
  extras,
  isObservable,
  createTransformer,
  extendObservable,
} from 'mobx'

import { BaseController } from 'cerebral'
import { extractModuleProp } from 'cerebral/internal'
import Model from './Model'
import Hoc from './Hoc'
import connectFactory, { decoratorFactory } from './connect'

export { default as Container } from './Container'
export const connect = connectFactory(Hoc)
export const decorator = decoratorFactory(Hoc)

// mobx uses extra fields in modules and therefore needs to declare it's own `Module` constructor.
export { Module } from 'cerebral'

class MobxController extends BaseController {
  constructor(rootModule, options) {
    super(rootModule, options)
    /*

    observeState(state) {
      const root = observable({})
      const extension = traverse(state, (parent, key, path) => {
        if (typeof parent[key] === 'function') {
          return createTransformer(parent[key].bind(root))
        } else if (isObservable(parent[key])) {
          return parent[key]
        } else if (isObject(parent[key]) && Object.keys(parent[key]).length) {
          return observable(parent[key])
        } else if (isObject(parent[key])) {
          return observable.map(parent[key])
        }

        return parent[key]
      })

      return extendObservable(
        root,
        Object.keys(extension).reduce((root, key) => {
          if (isObservable(extension[key])) {
            root[key] = observable.ref(extension[key])
          } else if ('get' in Object.getOwnPropertyDescriptor(extension, key)) {
            Object.defineProperty(
              root,
              key,
              Object.getOwnPropertyDescriptor(extension, key)
            )
          } else {
            root[key] = extension[key]
          }

          return root
        }, {})
      )
    }

    this.signals = extractModuleProp(
      this.module,
      'signals',
      (signals, module) => {
        return Object.keys(signals).reduce((runableSignals, key) => {
          if (signals[key].run) {
            runableSignals[key] = signals[key].run
          } else {
            runableSignals[key] = signals[key]
          }

          return runableSignals
        }, {})
      }
    )


        if (stateChanges) {
          untracked(() => {
            Object.keys(stateChanges).forEach(statePath => {
              updateIn(this.state, statePath.split('.'), (parentState, key) => {
                parentState[key] = stateChanges[statePath]
              })
            })
          })
        }



    useStrict(true)


    this.state = extractModuleProp(this.module, 'state', state => {
+      return this.observeState(state)
 })

      THIS SHOULD GO TO FUNCTION TREE
    +        executeBranchWrapper: cb => {
    +          extras.allowStateChanges(true, () => untracked(() => transaction(cb)))
             },


             addModule(path, module) {
               const pathArray = path.split('.')
               const moduleKey = pathArray.pop()
               const parentModule = getModule(pathArray, this.module)
               const newModule = module.create(this, pathArray.concat(moduleKey))
               parentModule.modules[moduleKey] = newModule

               if (newModule.providers) {
                 Object.assign(this.contextProviders, newModule.providers)
               }

               updateIn(this.state, pathArray.concat(moduleKey), (parentState, key) => {
                 parentState[key] = observable(newModule.state)
               })
               updateIn(this.signals, pathArray.concat(moduleKey), (parentState, key) => {
                 parentState[key] = Object.keys(
                   newModule.signals
                 ).reduce((signals, key) => {
                   signals[key] = newModule.signals[key].run

                   return signals
                 }, {})
               })

               this.emit('moduleAdded', path.split('.'), newModule)
             }
             removeModule(path) {
               if (!path) {
                 console.warn('Controller.removeModule requires a Module Path')
                 return null
               }

               const pathArray = path.split('.')
               const moduleKey = pathArray.pop()
               const parentModule = getModule(pathArray, this.module)

               const module = parentModule.modules[moduleKey]

               if (module.providers) {
                 Object.keys(module.providers).forEach(provider => {
                   delete this.contextProviders[provider]
                 })
               }

               delete parentModule.modules[moduleKey]
               updateIn(this.state, pathArray.concat(moduleKey), parentState => {
                 delete parentState[moduleKey]
               })
               updateIn(this.signals, pathArray.concat(moduleKey), parentSignals => {
                 delete parentSignals[moduleKey]
               })

               this.emit('moduleRemoved', path, module)
             }
  }
}

export function Controller(rootModule, options = {}) {
  options.Model = Model

  return new MobxController(rootModule, options)
}
*/
