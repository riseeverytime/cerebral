import { Primitive } from "../";

export interface IContext<TProps> {
    props: TProps;
}

export interface IBranchContext<TPaths, TProps> extends IContext<TProps> {
    path: {
        [key in keyof TPaths]: (props: TPaths[key]) => TPaths[key];
    };
}

export interface IBranchWithNoDataContext<TPaths, TProps> extends IContext<TProps> {
    path: {
        [key in keyof TPaths]: () => TPaths[key];
    };
}

export interface ISequenceBuilder<TContext, TProps> {
    action<TOutput>(...action: ((input: TContext & IContext<TProps>) => TOutput | Promise<TOutput>)[]) : SequenceBuilder<TContext, TProps & TOutput>
    action<TOutput>(name: string, ...action: ((input: TContext & IContext<TProps>) => TOutput | Promise<TOutput>)[]) : SequenceBuilder<TContext, TProps & TOutput>
    action<TOutput>(...action: any[]) : SequenceBuilder<TContext, TProps & TOutput>
    branch<TOutput, TPaths>(action: ((input: TContext & IBranchWithNoDataContext<TPaths, TProps>) => TOutput)) : {
        paths: (paths: { [key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]> }) => SequenceBuilder<TContext, TProps & TOutput>
    }
    branch<TOutput, TPaths>(action: ((input: TContext & IBranchContext<TPaths, TProps>) => TOutput)) : {
        paths: (paths: { [key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]> }) => SequenceBuilder<TContext, TProps & TOutput>
    }
    parallel<TOutput>(name: string, chain: ((input: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TOutput>)) : SequenceBuilder<TContext, TProps & TOutput>
    parallel<TOutput>(chain: ((input: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TOutput>)) : SequenceBuilder<TContext, TProps & TOutput>
    parallel<TOutput>(...args: any[]) : SequenceBuilder<TContext, TProps & TOutput>
    sequence<TOutput = void>(seq: (input: TProps) => TOutput | (() => TOutput)): SequenceBuilder<TContext, TProps & TOutput>
}

export declare class SequenceBuilder<TContext = {}, TProps = {}> {
    private sequenceArray;
    constructor(sequenceArray: any[]);
    action<TOutput>(...action: ((props: TContext & IContext<TProps>) => TOutput | Promise<TOutput>)[]): SequenceBuilder<TContext, TProps & TOutput>;
    action<TOutput>(name: string, ...action: ((props: TContext & IContext<TProps>) => TOutput | Promise<TOutput>)[]): SequenceBuilder<TContext, TProps & TOutput>;
    branch<TOutput, TPaths>(action: ((props: TContext & IBranchWithNoDataContext<TPaths, TProps>) => TOutput)) : { 
        paths: (paths: {
            [key in keyof TPaths]: (props: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]>;
        }) => SequenceBuilder<TContext, TProps & TOutput>;
    };
    branch<TOutput, TPaths>(action: ((props: TContext & IBranchContext<TPaths, TProps>) => TOutput)): {
        paths: (paths: {
            [key in keyof TPaths]: (props: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]>;
        }) => SequenceBuilder<TContext, TProps & TOutput>;
    };
    parallel<TOutput>(name: string, chain: ((props: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TOutput>)): SequenceBuilder<TContext, TProps & TOutput>;
    parallel<TOutput>(chain: ((props: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TOutput>)): SequenceBuilder<TContext, TProps & TOutput>;
    sequence<TOutput = void>(seq: (props: TProps) => TOutput | (() => TOutput)): SequenceBuilder<TContext, TProps & TOutput>;
}

export declare function sequenceFactory<TContext, TProps>(arg: (props: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TProps>): Primitive;

export declare function Sequence<Context, Output = {}>(arg: (props: SequenceBuilder<Context, {}>) => SequenceBuilder<Context, Output>): () => Output;

export declare function SequenceWithProps<Context, Props, Output = Props>(arg: (props: SequenceBuilder<Context, Props>) => SequenceBuilder<Context, Output>): (props: Props) => Output;

export declare function SequenceFactory<Context, Output = {}>(): <Output = {}>(arg: (props: SequenceBuilder<Context, {}>) => SequenceBuilder<Context, Output>) => () => Output;

export declare function SequenceWithPropsFactory<Context, Props, Output = Props>(): <Props, Output = Props>(arg: (props: SequenceBuilder<Context, Props>) => SequenceBuilder<Context, Output>) => (props: Props) => Output;
