import Provider from '../Provider'
import { Tag } from '../Tag'
import { ResolveValue } from '../ResolveValue'

export default new Provider(
  {
    isTag(arg, ...types) {
      if (!(arg instanceof Tag)) {
        return false
      }

      if (types.length) {
        return types.reduce((isType, type) => {
          return isType || type === arg.type
        }, false)
      }

      return true
    },
    isCompute(arg) {
      console.warn(
        '[DEPRECATION] Do not use this anymore, use "isResolveValue" which now returns true for both Tag and Compute.'
      )
      return arg instanceof ResolveValue && !(arg instanceof Tag)
    },
    isResolveValue(arg) {
      return arg instanceof ResolveValue
    },
    value(arg, overrides = {}) {
      if (arg instanceof ResolveValue) {
        return arg.getValue(
          overrides ? Object.assign({}, this.context, overrides) : this.context
        )
      }

      return arg
    },
    path(arg) {
      if (arg instanceof Tag) {
        return arg.getPath(this.context)
      }

      throw new Error(
        'You are extracting a path from an argument that is not a Tag.'
      )
    },
  },
  {
    wrap: false,
  }
)
