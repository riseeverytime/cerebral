/* eslint-env mocha */
import staticTree from './staticTree'
import { Sequence, Parallel } from './primitives'
import assert from 'assert'

describe('StaticTree', () => {
  it('should create a static tree of an array', () => {
    const tree = staticTree('Some name', [
      function test() {},
      { shortHand() {} }.shortHand,
    ])

    assert.strictEqual(tree.items.length, 2)
    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'sequence')
    assert.strictEqual(tree.items[0].name, 'test')
    assert.strictEqual(tree.items[1].name, 'shortHand')
    assert.strictEqual(tree.items[0].functionIndex, 0)
    assert.ok(tree.items[0].function)
  })
  it('should create a static tree of a function', () => {
    const tree = staticTree('Some name', function test() {})

    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'sequence')
    assert.strictEqual(tree.items.length, 1)
    assert.strictEqual(tree.items[0].name, 'test')
    assert.strictEqual(tree.items[0].functionIndex, 0)
    assert.ok(tree.items[0].function)
  })
  it('should throw when unexpected entry in tree', () => {
    assert.throws(
      () => {
        staticTree('Some name', [function a() {}, 1])
      },
      (err) => {
        if (
          err instanceof Error &&
          err.name === 'FunctionTreeError' &&
          err.toJSON
        ) {
          return (
            err
              .toJSON()
              .message.replace(/\n/g, '')
              .trim() ===
            'Unexpected entry in "Some name". [  a,  number, <-- PROBLEM]'
          )
        }
      }
    )
    assert.throws(
      () => {
        staticTree('someName', 1)
      },
      (err) => {
        if (
          err instanceof Error &&
          err.name === 'FunctionTreeError' &&
          err.toJSON
        ) {
          return err.toJSON().message === 'Unexpected entry in tree'
        }
      }
    )
  })
  it('should handle paths', () => {
    const tree = staticTree('Some name', [
      function a() {},
      {
        foo: [function b() {}],
      },
    ])

    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'sequence')
    assert.strictEqual(tree.items.length, 1)
    assert.strictEqual(tree.items[0].name, 'a')
    assert.strictEqual(tree.items[0].functionIndex, 0)
    assert.ok(tree.items[0].function)
    assert.strictEqual(tree.items[0].outputs.foo.items[0].name, 'b')
    assert.strictEqual(tree.items[0].outputs.foo.items[0].functionIndex, 1)
    assert.ok(tree.items[0].outputs.foo.items[0].function)
  })
  it('should identify parallel execution', () => {
    const tree = staticTree('Some name', [
      new Parallel([function a() {}, function b() {}]),
    ])

    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'sequence')
    assert.strictEqual(tree.items.length, 1)
    assert.strictEqual(tree.items[0].items[0].name, 'a')
    assert.strictEqual(tree.items[0].items[0].functionIndex, 0)
    assert.ok(tree.items[0].items[0].function)
    assert.strictEqual(tree.items[0].items[1].name, 'b')
    assert.strictEqual(tree.items[0].items[1].functionIndex, 1)
    assert.ok(tree.items[0].items[1].function)
  })
  it('should identify parallel execution at root', () => {
    const tree = staticTree(
      'Some name',
      new Parallel([function a() {}, function b() {}])
    )

    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'parallel')
    assert.strictEqual(tree.items.length, 2)
    assert.strictEqual(tree.items[0].functionIndex, 0)
    assert.ok(tree.items[0].function)
    assert.strictEqual(tree.items[1].name, 'b')
    assert.strictEqual(tree.items[1].functionIndex, 1)
    assert.ok(tree.items[1].function)
  })
  it('should not identify parallel execution as outputs', () => {
    const tree = staticTree('Some name', [
      function someFunc() {},
      new Parallel([function a() {}, function b() {}]),
    ])

    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'sequence')
    assert.strictEqual(tree.items.length, 2)
    assert.strictEqual(tree.items[0].name, 'someFunc')
    assert.strictEqual(tree.items[0].functionIndex, 0)

    assert.strictEqual(tree.items[1]._functionTreePrimitive, true)
    assert.strictEqual(tree.items[1].items[0].name, 'a')
    assert.strictEqual(tree.items[1].items[0].functionIndex, 1)
    assert.strictEqual(tree.items[1].items[1].name, 'b')
    assert.strictEqual(tree.items[1].items[1].functionIndex, 2)
  })
  it('should allow sequence in parallel', () => {
    const tree = staticTree('Some name', [
      function someFunc() {},
      new Parallel([function a() {}, new Sequence([function b() {}])]),
    ])

    assert.strictEqual(tree._functionTreePrimitive, true)
    assert.strictEqual(tree.type, 'sequence')
    assert.strictEqual(tree.items.length, 2)
    assert.strictEqual(tree.items[0].name, 'someFunc')
    assert.strictEqual(tree.items[0].functionIndex, 0)

    assert.strictEqual(tree.items[1]._functionTreePrimitive, true)
    assert.strictEqual(tree.items[1].items[0].name, 'a')
    assert.strictEqual(tree.items[1].items[0].functionIndex, 1)
    assert.strictEqual(tree.items[1].items[1].items[0].name, 'b')
    assert.strictEqual(tree.items[1].items[1].items[0].functionIndex, 2)
  })
})
