import assert from 'assert'

/* eslint-env mocha */
import { Server, WebSocket } from 'mock-socket'

import { FunctionTree, Provider } from '../'
import Devtools from './'

let devtools

describe('Devtools', () => {
  beforeEach(() => {
    Devtools.prototype.createSocket = function() {
      this.ws = new WebSocket(`ws://${this.host}`)
    }

    Devtools.prototype.reconnect = function() {
      this.reconnectTimeout = setTimeout(() => {
        this.init()
      }, this.reconnectInterval)
    }

    Devtools.prototype.destroy = function() {
      clearTimeout(this.reconnectTimeout)
    }
  })
  afterEach(() => {
    devtools && devtools.destroy()
  })
  describe('DevtoolsBase', () => {
    it('should throw when host is not set', () => {
      assert.throws(
        () => {
          devtools = new Devtools() // eslint-disable-line no-new
        },
        (err) => {
          if (err instanceof Error) {
            return (
              err.message === 'Devtools: You have to pass in the "host" option'
            )
          }
        }
      )
    })
  })
  it('should init correctly', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        // client send ping
        assert.strictEqual(message.type, 'ping')
      })
      assert.ok(server)
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })
    setTimeout(() => {
      assert.strictEqual(devtools.isConnected, false)
      assert.strictEqual(devtools.reconnectInterval, 10000)
      assert.strictEqual(devtools.doReconnect, true)
      mockServer.stop(done)
    }, 70)
  })
  it('should work when debugger is already opened', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = []
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        messages.push(message.type)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })
    setTimeout(() => {
      assert.deepStrictEqual(messages, ['ping', 'init'])
      assert.strictEqual(devtools.isConnected, true)
      mockServer.stop(done)
    }, 70)
  })
  it('should warn and reconnect to Debugger', (done) => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'Debugger application is not running on selected port... will reconnect automatically behind the scenes'
      )
      originWarn.apply(this, args)
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      reconnectInterval: 500,
    })
    let mockServer
    const messages = []
    setTimeout(() => {
      mockServer = new Server('ws://localhost:8585')
      mockServer.on('connection', (server) => {
        server.on('message', (event) => {
          const message = JSON.parse(event)
          messages.push(message.type)
          switch (message.type) {
            case 'pong':
              server.send(JSON.stringify({ type: 'ping' }))
              break
            case 'ping':
              server.send(JSON.stringify({ type: 'pong' }))
              break
          }
        })
      })
    }, 400)

    setTimeout(() => {
      assert.deepStrictEqual(messages, ['ping', 'init'])
      assert.strictEqual(warnCount, 1)
      assert.strictEqual(devtools.isConnected, true)
      console.warn = originWarn
      mockServer.stop(done)
    }, 1050)
  })
  it('should add function tree', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })

    setTimeout(() => {
      const ft = new FunctionTree()
      assert.strictEqual(Object.keys(ft.contextProviders).length, 1)
      devtools.add(ft)
      assert.strictEqual(Object.keys(ft.contextProviders).length, 2)
      assert.strictEqual(devtools.trees.length, 1)
      assert.deepStrictEqual(devtools.trees[0], ft)
      assert.strictEqual(devtools.isConnected, true)
      mockServer.stop(done)
    }, 70)
  })
  it('should remove function tree', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })

    setTimeout(() => {
      const ft = new FunctionTree()
      devtools.add(ft)
      devtools.remove(ft)
      assert.strictEqual(Object.keys(ft.contextProviders).length, 1)
      assert.strictEqual(devtools.trees.length, 0)
      assert.strictEqual(devtools.isConnected, true)
      mockServer.stop(done)
    }, 70)
  })
  it('should remove all trees', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })

    setTimeout(() => {
      const ftA = new FunctionTree()
      ftA.type = 'A'
      devtools.add(ftA)
      assert.strictEqual(Object.keys(ftA.contextProviders).length, 2)
      assert.strictEqual(devtools.trees.length, 1)
      const ftB = new FunctionTree()
      ftB.type = 'B'
      devtools.add(ftB)
      assert.strictEqual(Object.keys(ftB.contextProviders).length, 2)
      assert.strictEqual(devtools.trees.length, 2)
      devtools.removeAll()
      assert.strictEqual(Object.keys(ftA.contextProviders).length, 1)
      assert.strictEqual(Object.keys(ftB.contextProviders).length, 1)
      assert.strictEqual(devtools.trees.length, 0)
      assert.strictEqual(devtools.isConnected, true)
      mockServer.stop(done)
    }, 70)
  })
  it('should watch function tree executions', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = {}
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          case 'init':
            break
          default:
            messages[message.type] = message
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })
    const ft = new FunctionTree()
    devtools.add(ft)

    function actionA({ path }) {
      assert.ok(true)

      return path.success()
    }
    function actionB() {
      assert.ok(true)
      return { bar: 'baz' }
    }

    setTimeout(() => {
      ft.run(
        [
          actionA,
          {
            success: [actionB],
          },
        ],
        {
          foo: 'bar',
        }
      )

      setTimeout(() => {
        assert.deepStrictEqual(Object.keys(messages), [
          'executionStart',
          'execution',
          'executionPathStart',
          'executionFunctionEnd',
          'executionEnd',
        ])
        assert.ok(messages.executionStart.data.execution)
        assert.strictEqual(messages.executionStart.source, 'ft')

        assert.ok(messages.execution.data.execution)
        assert.strictEqual(messages.execution.source, 'ft')
        assert.deepStrictEqual(messages.execution.data.execution.payload, {
          foo: 'bar',
        })

        assert.ok(messages.executionPathStart.data.execution)
        assert.strictEqual(messages.executionPathStart.source, 'ft')
        assert.strictEqual(
          messages.executionPathStart.data.execution.path,
          'success'
        )

        assert.ok(messages.executionFunctionEnd.data.execution)
        assert.strictEqual(messages.executionFunctionEnd.source, 'ft')
        assert.deepStrictEqual(
          messages.executionFunctionEnd.data.execution.output,
          {
            bar: 'baz',
          }
        )

        assert.ok(messages.executionEnd.data.execution)
        assert.strictEqual(messages.executionEnd.source, 'ft')

        mockServer.stop(done)
      }, 10)
    }, 70)
  })
  it('should watch function tree execution error', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = {}
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          case 'init':
            break
          default:
            messages[message.type] = message
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })
    const ft = new FunctionTree()
    devtools.add(ft)

    function actionA() {
      return {
        foo: 'bar',
      }
    }

    ft.once('error', (error) => {
      assert.ok(error.message.match(/needs to be a path of either success/))
    })

    setTimeout(() => {
      ft.run([
        actionA,
        {
          success: [],
        },
      ]).catch((error) => {
        assert.ok(error.message.match(/needs to be a path of either success/))
      })

      setTimeout(() => {
        assert.deepStrictEqual(Object.keys(messages), [
          'executionStart',
          'execution',
          'executionFunctionError',
        ])
        assert.ok(messages.executionStart.data.execution)
        assert.strictEqual(messages.executionStart.source, 'ft')

        assert.ok(messages.execution.data.execution)
        assert.strictEqual(messages.execution.source, 'ft')

        assert.ok(messages.executionFunctionError.data.execution)
        assert.strictEqual(messages.executionFunctionError.source, 'ft')
        assert.strictEqual(
          messages.executionFunctionError.data.execution.error.name,
          'FunctionTreeExecutionError'
        )
        assert.strictEqual(
          messages.executionFunctionError.data.execution.error.func,
          actionA.toString()
        )
        assert.ok(
          messages.executionFunctionError.data.execution.error.message.match(
            /needs to be a path of either success/
          )
        )

        mockServer.stop(done)
      }, 10)
    }, 70)
  })
  it('should keep execution messages when debugger is not ready and send bulk messages after debugger is ready', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = {}
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          case 'init':
            break
          default:
            messages[message.type] = message
            break
        }
      })
    })

    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })
    const ft = new FunctionTree()
    devtools.add(ft)

    function actionA({ path }) {
      assert.ok(true)
      return path.success()
    }
    function actionB() {
      assert.ok(true)
      return { bar: 'baz' }
    }
    ft.run(
      [
        actionA,
        {
          success: [actionB],
        },
      ],
      {
        foo: 'bar',
      }
    )

    setTimeout(() => {
      assert.deepStrictEqual(Object.keys(messages), ['bulk'])
      assert.strictEqual(messages.bulk.data.messages.length, 6)

      const executionStartMessage = JSON.parse(messages.bulk.data.messages[0])
      assert.strictEqual(executionStartMessage.type, 'executionStart')
      assert.ok(executionStartMessage.data.execution)
      assert.strictEqual(executionStartMessage.source, 'ft')

      let executionMessage = JSON.parse(messages.bulk.data.messages[1])
      assert.strictEqual(executionMessage.type, 'execution')
      assert.ok(executionMessage.data.execution)
      assert.strictEqual(executionMessage.source, 'ft')
      assert.deepStrictEqual(executionMessage.data.execution.payload, {
        foo: 'bar',
      })

      const executionPathStartMessage = JSON.parse(
        messages.bulk.data.messages[2]
      )
      assert.strictEqual(executionPathStartMessage.type, 'executionPathStart')
      assert.ok(executionPathStartMessage.data.execution)
      assert.strictEqual(executionPathStartMessage.source, 'ft')
      assert.strictEqual(
        executionPathStartMessage.data.execution.path,
        'success'
      )

      executionMessage = JSON.parse(messages.bulk.data.messages[3])
      assert.strictEqual(executionMessage.type, 'execution')
      assert.ok(executionMessage.data.execution)
      assert.strictEqual(executionMessage.source, 'ft')
      assert.deepStrictEqual(executionMessage.data.execution.payload, {
        foo: 'bar',
      })

      const executionFunctionEndMessage = JSON.parse(
        messages.bulk.data.messages[4]
      )
      assert.strictEqual(
        executionFunctionEndMessage.type,
        'executionFunctionEnd'
      )
      assert.ok(executionFunctionEndMessage.data.execution)
      assert.strictEqual(executionFunctionEndMessage.source, 'ft')
      assert.deepStrictEqual(
        executionFunctionEndMessage.data.execution.output,
        {
          bar: 'baz',
        }
      )

      const executionEndMessage = JSON.parse(messages.bulk.data.messages[5])
      assert.strictEqual(executionEndMessage.type, 'executionEnd')
      assert.ok(executionEndMessage.data.execution)
      assert.strictEqual(executionEndMessage.source, 'ft')

      mockServer.stop(done)
    }, 70)
  })
  it('should send provider data', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = {}
    const messageTypes = []
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          case 'init':
            break
          case 'execution':
            messageTypes.push(message.type)
            if (Array.isArray(messages[message.type])) {
              messages[message.type].push(message)
            } else {
              messages[message.type] = [message]
            }
            break
          default:
            messageTypes.push(message.type)
            messages[message.type] = message
            break
        }
      })
    })
    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
    })
    const ft = new FunctionTree({
      myProvider: new Provider({
        doSomething(value) {
          return value
        },
      }),
    })
    devtools.add(ft)

    function actionA({ myProvider }) {
      assert.ok(true)
      assert.strictEqual(myProvider.doSomething('bar'), 'bar')
    }

    setTimeout(() => {
      ft.run([actionA], {
        foo: 'bar',
      })

      setTimeout(() => {
        assert.deepStrictEqual(messageTypes, [
          'executionStart',
          'execution',
          'execution',
          'executionEnd',
        ])
        assert.ok(messages.executionStart.data.execution)
        assert.strictEqual(messages.executionStart.source, 'ft')

        assert.strictEqual(messages.execution.length, 2)
        assert.ok(messages.execution[0].data.execution)
        assert.strictEqual(messages.execution[0].source, 'ft')
        assert.deepStrictEqual(messages.execution[0].data.execution.payload, {
          foo: 'bar',
        })

        assert.ok(messages.execution[1].data.execution)
        assert.strictEqual(messages.execution[1].source, 'ft')
        assert.deepStrictEqual(messages.execution[1].data.execution.payload, {
          foo: 'bar',
        })
        assert.strictEqual(
          messages.execution[1].data.execution.data.method,
          'myProvider.doSomething'
        )
        assert.deepStrictEqual(messages.execution[1].data.execution.data.args, [
          'bar',
        ])

        assert.ok(messages.executionEnd.data.execution)
        assert.strictEqual(messages.executionEnd.source, 'ft')

        mockServer.stop(done)
      }, 10)
    }, 70)
  })
})
