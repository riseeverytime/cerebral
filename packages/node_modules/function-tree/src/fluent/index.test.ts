/* eslint-env mocha */
// @ts-ignore: stupid module
import * as assert from 'assert'
import { SequenceFactory, SequenceWithPropsFactory, SequenceBuilder, IContext, IBranchContext } from './'
import { Primitive } from '../../';

interface MyModel {
    stateData: string
}

interface ProviderContext {
    //http: HttpModule
    state: MyModel
};

type MyContext<TProps = {}> = IContext<TProps> & ProviderContext;
type MyBranchContext<TPaths = {}, TProps = {}> = IBranchContext<TPaths, TProps> & ProviderContext;

const Sequence = SequenceFactory<MyContext>();
const SequenceWithProps = SequenceWithPropsFactory<MyContext>();

interface Props {
    name: string,
    age: number
}

describe('Fluent', () => {
  it('should return array', () => {

    function action1(context: MyContext<{}>) {

    }

    var seq = Sequence(x => x
        .action(action1)
    ) as any as Array<any>;

    assert.deepEqual(seq, [action1])
  })

  it('should return paths correctly', () => {

    interface PathResult {
        newName: string
    }

    interface Paths {
        success: PathResult,
        error: PathResult
    }

    function action1(context: MyContext<Props>) { }

    function action2(context: MyContext<Props>) { }

    function action3(context: MyBranchContext<Paths>) : PathResult {
        context.state.stateData = "Something";
        return context.path.success({ newName: "John" });
    }

    var seq = SequenceWithProps<Props>(x => x
        .action(action1)
        .branch(action3)
        .paths({
            success: z => z.action(action1, action2),
            error: z => z.action(action2)
        })
    ) as any as Array<any>;

    assert.deepEqual(seq, [
        action1,
        action3,
        {
            success: [action1, action2],
            error: [action2]
        }
    ])
  })
})
