import { sequence, parallel, Primitive } from "../../";

export interface IContext<TInput> {
	props: TInput,
}

export interface IContextWithPaths<TInput, TPathModel> extends IContext<TInput> {
	path: { [key in keyof TPathModel]: (input: TPathModel[key]) => TPathModel[key] }
}

export class ChainBuilder<TContext = {}, TInput = {}> {
	private sequenceArray: any[];

	constructor(sequenceArray: any[]) {
		this.sequenceArray = sequenceArray;
	}
	action<TOutput>(...action: ((input: TContext & IContext<TInput>) => TOutput | Promise<TOutput>)[]) : ChainBuilder<TContext, TInput & TOutput> 
	action<TOutput>(name: string, ...action: ((input: TContext & IContext<TInput>) => TOutput | Promise<TOutput>)[]) : ChainBuilder<TContext, TInput & TOutput> 
	action<TOutput>(...action: any[]) : ChainBuilder<TContext, TInput & TOutput> {
		var typeFirst = typeof action[0] === "string";
		var actions = <any[]> (typeFirst ? action.splice(1) : action);
		actions.forEach(element => {
			typeFirst && Object.defineProperty(element, "name", { value: action[0] });
		});
		this.sequenceArray.push(...actions);
		return new ChainBuilder<TContext, TInput & TOutput>(this.sequenceArray);
	}
	actionWithPaths<TOutput, TPathModel>(action: ((input: TContext & IContextWithPaths<TInput, TPathModel>) => TOutput)) {
		this.sequenceArray.push(action);

		return {
			paths: (paths: { [key in keyof TPathModel]: (input: ChainBuilder<TContext, TInput & TPathModel[key]>) => ChainBuilder<TContext, TInput & TPathModel[key]> }): ChainBuilder<TContext, TInput & TOutput> => {
				let outputSequence: { [key in keyof TPathModel]?: any[] } = {};
				for(let key in paths) {
					let cb = new ChainBuilder<TContext, TInput>([]);
					let chain = paths[key];
                    chain(cb as any);
					outputSequence[key] = cb.sequenceArray;
				}
		
				this.sequenceArray.push(outputSequence);
		
				return new ChainBuilder<TContext, TInput & TOutput>(this.sequenceArray);
			}
		};
	}
	parallel<TOutput>(name: string, chain: ((input: ChainBuilder<TContext, TInput>) => ChainBuilder<TContext, TOutput>)) : ChainBuilder<TContext, TInput & TOutput>
	parallel<TOutput>(chain: ((input: ChainBuilder<TContext, TInput>) => ChainBuilder<TContext, TOutput>)) : ChainBuilder<TContext, TInput & TOutput>
	parallel<TOutput>(...args: any[]) : ChainBuilder<TContext, TInput & TOutput> {
		var cb = new ChainBuilder<TContext, TInput>([]);
		var callback = typeof(args[0]) == "string" ? args[1] : args[0];
		var name = typeof(args[0]) == "string" ? args[0] : "";
		var result = callback(cb);
		this.sequenceArray.push(parallel(name, result.sequenceArray));
		return new ChainBuilder<TContext, TInput & TOutput>(this.sequenceArray);
	}
	sequence<TOutput = void>(seq: (input: TInput) => TOutput | (() => TOutput)) {
		this.sequenceArray.push(...(seq as any));
		return new ChainBuilder<TContext, TInput & TOutput>(this.sequenceArray);
	}
}

export function chainFactory<TContext, TInput>(arg: (input: ChainBuilder<TContext, TInput>) => ChainBuilder<TContext, TInput>): Primitive {
	var builder = new ChainBuilder<TContext, TInput>([]);
	arg(builder);
	return (builder as any).sequenceArray;
}