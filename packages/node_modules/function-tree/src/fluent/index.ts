import { sequence, parallel, Primitive } from "../../";
import { debounce } from '../../factories/';

export interface IContext<TProps> {
	props: TProps,
}

export interface IBranchContext<TPaths, TProps> extends IContext<TProps> {
	path: {[key in keyof TPaths]: (props: TPaths[key]) => TPaths[key]}
}

export class SequenceBuilder<TContext = {}, TProps = {}> {
	private sequenceArray: any[];

	constructor(sequenceArray: any[]) {
		this.sequenceArray = sequenceArray;
	}
	action<TOutput>(...action: ((input: TContext & IContext<TProps>) => TOutput | Promise<TOutput>)[]): SequenceBuilder<TContext, TProps & TOutput>
	action<TOutput>(name: string, ...action: ((input: TContext & IContext<TProps>) => TOutput | Promise<TOutput>)[]): SequenceBuilder<TContext, TProps & TOutput>
	action<TOutput>(...action: any[]): SequenceBuilder<TContext, TProps & TOutput> {
		var typeFirst = typeof action[0] === "string";
		var actions = <any[]>(typeFirst ? action.splice(1) : action);
		actions.forEach(element => {
			typeFirst && Object.defineProperty(element, "name", { value: action[0] });
		});
		this.sequenceArray.push(...actions);
		return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray);
	}
	branch<TOutput, TPaths>(action: ((input: TContext & IBranchContext<TPaths, TProps>) => TOutput | Promise<TOutput>)): {
		paths: (paths: {[key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]> }) => SequenceBuilder<TContext, TProps & TOutput>
	};
	branch<TOutput, TPaths>(action: any): {
		paths: (paths: {[key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]> }) => SequenceBuilder<TContext, TProps & TOutput>
	} {
		this.sequenceArray.push(action);

		return {
			paths: (paths: {[key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]> }): SequenceBuilder<TContext, TProps & TOutput> => {
				let outputSequence = generatePathSequence<TPaths, TContext, TProps>(paths);
				this.sequenceArray.push(outputSequence);
				return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray);
			}
		};
	}
	parallel<TOutput>(name: string, chain: ((input: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TOutput>)): SequenceBuilder<TContext, TProps & TOutput>
	parallel<TOutput>(chain: ((input: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TOutput>)): SequenceBuilder<TContext, TProps & TOutput>
	parallel<TOutput>(...args: any[]): SequenceBuilder<TContext, TProps & TOutput> {
		var cb = new SequenceBuilder<TContext, TProps>([]);
		var callback = typeof (args[0]) == "string" ? args[1] : args[0];
		var name = typeof (args[0]) == "string" ? args[0] : "";
		var result = callback(cb);
		this.sequenceArray.push(parallel(name, result.sequenceArray));
		return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray);
	}
	sequence<TOutput = void>(seq: (input: TProps) => TOutput | (() => TOutput)): SequenceBuilder<TContext, TProps & TOutput> {
		this.sequenceArray.push(...(seq as any));
		return new SequenceBuilder<TContext, TProps & TOutput>(this.sequenceArray);
	}
	when<TPaths extends { true: {}, false: {} }>(callback: (input: TContext & IBranchContext<TPaths, TProps>) => boolean): {
		paths: (paths: {[key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]>; }) => SequenceBuilder<TContext, TProps>;
	} {
		return this.branch(function when(context: TContext & IBranchContext<TPaths, TProps>) {
			return callback(context) ? context.path.true({}) : context.path.false({});
		});
	}
	debounce<TPaths extends { continue: {}, discard: {} }>(seconds: number): {
		paths: (paths: {[key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]>; }) => SequenceBuilder<TContext, TProps>;
	} {
		return this.branch<{}, TPaths>(debounce(seconds) as any);
	}
	equals<TPaths extends { [key: string]: {} }, TValue>(callback: (input: TContext & IBranchContext<TPaths, TProps>) => TValue) {
		return this.branch<{}, TPaths>(function equals(context: TContext & IBranchContext<TPaths, TProps>) {
			var result = String(callback(context));
			return context.path[result]({});
		});
	}
}

function generatePathSequence<TPaths, TContext = {}, TProps = {}>(paths: {[key in keyof TPaths]: (input: SequenceBuilder<TContext, TProps & TPaths[key]>) => SequenceBuilder<TContext, TProps & TPaths[key]>; }) {
	let outputSequence: {[key in keyof TPaths]?: any[]; } = {};
	for (let key in paths) {
		let cb = new SequenceBuilder<TContext, TProps>([]);
		let chain = paths[key];
		chain(cb as any);
		outputSequence[key] = (cb as any).sequenceArray;
	}
	return outputSequence;
}

export function sequenceFactory<TContext, TProps>(arg: (input: SequenceBuilder<TContext, TProps>) => SequenceBuilder<TContext, TProps>): Primitive {
	var builder = new SequenceBuilder<TContext, TProps>([]);
	arg(builder);
	return (builder as any).sequenceArray;
}

export function Sequence<Context, Output = {}>(
	arg: (props: SequenceBuilder<Context, {}>) => SequenceBuilder<Context, Output>
): () => Output {
	return sequenceFactory<Context, {}>(arg as any) as any;
}

export function SequenceWithProps<Context, Props, Output = Props>(
	arg: (props: SequenceBuilder<Context, Props>) => SequenceBuilder<Context, Output>
): (props: Props) => Output {
	return sequenceFactory<Context, Props>(arg as any) as any;
}

export function SequenceFactory<Context>() {
	function returned<Output = {}>(arg: (props: SequenceBuilder<Context, {}>) => SequenceBuilder<Context, Output>): () => Output {
		return sequenceFactory<Context, {}>(arg as any) as any;
	}
	return returned;
}

export function SequenceWithPropsFactory<Context>() {
	function returned<Props, Output = Props>(arg: (props: SequenceBuilder<Context, Props>) => SequenceBuilder<Context, Output>): (props: Props) => Output {
		return sequenceFactory<Context, Props>(arg as any) as any;
	}
	return returned;
}