import { Primitive } from "../../";
export interface IContext<TInput> {
    props: TInput;
}
export interface IContextWithPaths<TInput, TPathModel> extends IContext<TInput> {
    path: {
        [key in keyof TPathModel]: (input: TPathModel[key]) => TPathModel[key];
    };
}
export declare class ChainBuilder<TContext = {}, TInput = {}> {
    private sequenceArray;
    constructor(sequenceArray: any[]);
    action<TOutput>(...action: ((input: TContext & IContext<TInput>) => TOutput | Promise<TOutput>)[]): ChainBuilder<TContext, TInput & TOutput>;
    action<TOutput>(name: string, ...action: ((input: TContext & IContext<TInput>) => TOutput | Promise<TOutput>)[]): ChainBuilder<TContext, TInput & TOutput>;
    actionWithPaths<TOutput, TPathModel>(action: ((input: TContext & IContextWithPaths<TInput, TPathModel>) => TOutput)): {
        paths: (paths: {
            [key in keyof TPathModel]: (input: ChainBuilder<TContext, TInput & TPathModel[key]>) => ChainBuilder<TContext, TInput & TPathModel[key]>;
        }) => ChainBuilder<TContext, TInput & TOutput>;
    };
    parallel<TOutput>(name: string, chain: ((input: ChainBuilder<TContext, TInput>) => ChainBuilder<TContext, TOutput>)): ChainBuilder<TContext, TInput & TOutput>;
    parallel<TOutput>(chain: ((input: ChainBuilder<TContext, TInput>) => ChainBuilder<TContext, TOutput>)): ChainBuilder<TContext, TInput & TOutput>;
    sequence<TOutput = void>(seq: (input: TInput) => TOutput | (() => TOutput)): ChainBuilder<TContext, TInput & TOutput>;
}
export declare function chainFactory<TContext, TInput>(arg: (input: ChainBuilder<TContext, TInput>) => ChainBuilder<TContext, TInput>): Primitive;
