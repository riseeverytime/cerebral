import { moduleState, props, sequences, state } from './tags'

/* eslint-env mocha */
/* eslint-disable no-global-assign */
/* eslint-disable no-new */
import App from './'
import View from './View'
import assert from 'assert'
import { set } from './factories'

describe('View', () => {
  it('should throw an error if dependency is a function', () => {
    assert.throws(
      () => {
        new View({
          dependencies: () => {},
        })
      },
      (err) => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - You can not use a function to define dependencies. Use tags or a function on the specific property you want to dynamically create'
          )
        }
      }
    )
  })
  it('should throw an error if dependency item is not tag', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    assert.throws(
      () => {
        new View({
          displayName: 'test',
          dependencies: {
            foo: () => {},
          },
          controller,
        })
      },
      (err) => {
        if (err instanceof Error) {
          return (
            err.message ===
            'Cerebral - The dependency "foo" on component "test" is not a tag, it has to be a tag'
          )
        }
      }
    )
  })
  it('should return undefined when sequence is not defined', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
        fooCalled: sequences`fooCalled`,
      },
      controller,
      displayName: 'Test',
    })
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.fooCalled, undefined)
    })
  })
  it('should warn if component has more dependencies than devtools configuration', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'Component named Test has a lot of dependencies, consider refactoring or adjust this option in devtools'
      )
    }

    const rootModule = {
      state: {
        foo: 'foo',
        bar: 'bar',
      },
      sequences: {
        fooCalled: [],
      },
    }
    const controller = App(rootModule, {
      devtools: {
        bigComponentsWarning: 2,
        init() {},
        send() {},
        updateWatchMap() {},
        updateComputedMap() {},
        sendWatchMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        fooCalled: sequences`fooCalled`,
      },
      controller,
      displayName: 'Test',
    })
    view.render()
    assert.strictEqual(view._hasWarnedBigComponent, true)
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
  })
  it('should be able to extract state', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
    })
    assert.strictDeepEqual(view.controller.getState(), { foo: 'bar' })
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
    })
  })
  it('should be able to extract sequences', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
      sequences: {
        someSequence: [],
      },
      modules: {
        someModule: {
          sequences: {
            moduleSequence: [],
          },
        },
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
        sequence: sequences`someSequence`,
        moduleSequences: sequences`someModule`,
      },
      controller,
    })
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.ok(typeof componentProps.sequence === 'function')
      assert.ok(
        typeof componentProps.moduleSequences.moduleSequence === 'function'
      )
    })
  })
  it('should allow props tag', () => {
    const rootModule = {
      state: {
        foo: {
          baz: 'mip',
        },
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        a: props`foo`,
        b: props`bar.id`,
        c: state`foo.${props`propKey`}`,
      },
      controller,
      props: {
        foo: 'bar',
        bar: { id: '1' },
        propKey: 'baz',
      },
    })
    view.render(
      {
        foo: 'bar',
        bar: { id: '1' },
        propKey: 'baz',
      },
      (componentProps) => {
        assert.strictEqual(componentProps.a, 'bar')
        assert.strictEqual(componentProps.b, '1')
        assert.strictEqual(componentProps.c, 'mip')
      }
    )
  })
  it('should be able to dynamically define sequences', () => {
    const rootModule = {
      state: {
        test: '',
      },
      sequences: {
        foo: [({ store }) => store.set(state`test`, 'fooSequence')],
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        sequence: sequences`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })

    view.render(
      {
        path: 'foo',
      },
      (componentProps) => {
        componentProps.sequence()
      }
    )
    assert.strictEqual(controller.getModel().get(['test']), 'fooSequence')
  })
  it('should be able to adjust props with function (mergeProps)', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
      sequences: {
        foo: [],
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
        fooSequence: sequences`foo`,
      },
      mergeProps: (depsProps, ownProps, get) => {
        assert.strictEqual(depsProps.foo, 'bar')
        assert.strictEqual(typeof depsProps.fooSequence, 'function')
        assert.strictDeepEqual(ownProps, { mip: 'mop' })
        assert.strictEqual(get(state`foo`), 'bar')

        return { bar: depsProps.foo + ownProps.mip }
      },
      props: {
        mip: 'mop',
      },
      controller,
    })
    view.render(
      {
        mip: 'mop',
      },
      (componentProps) => {
        assert.strictEqual(componentProps.bar, 'barmop')
        assert.strictEqual(componentProps.foo, undefined)
        assert.strictEqual(componentProps.fooSequence, undefined)
      }
    )
  })
  it('should mount correctly', () => {
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      displayName: 'Test',
      onUpdate: function() {},
    })
    view.mount()
    assert.strictDeepEqual(view.dependencyMap, { foo: true })
    assert.strictEqual(typeof view.onUpdate, 'function')
  })
  it('should update devtools components map and add entity to controller dependency store when mounting', () => {
    let devtoolsUpdateWatchMapCalled = 0
    let dependencyStoreAddEntityCalled = 0
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateWatchMap(component, nextDeps, prevDeps) {
          assert.strictDeepEqual(nextDeps, { foo: true })
          assert.strictDeepEqual(prevDeps, {})
          assert.strictEqual(component._displayName, 'Test')
          devtoolsUpdateWatchMapCalled++
        },
        updateComputedMap() {},
        sendWatchMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        path: props`path`,
      },
      props: { path: 'foo' },
      controller,
      displayName: 'Test',
    })
    view.controller.dependencyStore.addEntity = function(component, depsMap) {
      assert.strictDeepEqual(depsMap, { foo: true })
      assert.strictEqual(component._displayName, 'Test')
      dependencyStoreAddEntityCalled++
    }
    view.mount()
    assert.strictEqual(devtoolsUpdateWatchMapCalled, 1)
    assert.strictEqual(dependencyStoreAddEntityCalled, 1)
  })
  it('should update devtools components map and remove entity from controller dependency store when unmounting', () => {
    let devtoolsUpdateWatchMapCalled = 0
    let dependencyStoreRemoveEntityCalled = 0
    const rootModule = {
      state: {
        foo: 'bar',
      },
    }
    const controller = App(rootModule, {
      devtools: {
        init() {},
        send() {},
        updateWatchMap(component, nextDeps, prevDeps) {
          assert.strictDeepEqual(nextDeps, { foo: true })
          assert.strictDeepEqual(prevDeps, {})
          assert.strictEqual(component._displayName, 'Test')
          devtoolsUpdateWatchMapCalled++
        },
        updateComputedMap() {},
        sendWatchMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        path: props`path`,
      },
      props: { path: 'foo' },
      controller,
      displayName: 'Test',
    })
    view.mount()
    view.controller.dependencyStore.removeEntity = function(
      component,
      depsMap
    ) {
      assert.strictDeepEqual(depsMap, { foo: true })
      assert.strictEqual(component._displayName, 'Test')
      dependencyStoreRemoveEntityCalled++
    }
    view.controller.devtools.updateWatchMap = function(
      component,
      nextDeps,
      prevDeps
    ) {
      assert.strictDeepEqual(prevDeps, { foo: true })
      assert.strictEqual(nextDeps, null)
      assert.strictEqual(component._displayName, 'Test')
      devtoolsUpdateWatchMapCalled++
    }
    view.unMount()
    assert.strictEqual(devtoolsUpdateWatchMapCalled, 2)
    assert.strictEqual(dependencyStoreRemoveEntityCalled, 1)
  })
  it('should update tags', () => {
    let renderCount = 0
    const rootModule = {
      state: {
        list: {
          0: 'foo',
          1: 'bar',
        },
        currentItem: '0',
      },
      sequences: {
        test: [
          ({ store }) => {
            store.set(state`currentItem`, '1')
          },
        ],
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`list.${state`currentItem`}`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 1)
        assert.strictDeepEqual(stateChanges[0].path, ['currentItem'])
        assert.strictEqual(force, undefined)
        view.updateFromState(stateChanges, null, force)
        assert.strictDeepEqual(view.dependencyMap, {
          'list.1': true,
          currentItem: true,
        })
        renderCount++
      },
    })
    view.mount()
    assert.strictDeepEqual(view.dependencyMap, {
      'list.0': true,
      currentItem: true,
    })
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'foo')
    })
    view.controller.getSequence('test')()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
    })
    assert.strictEqual(renderCount, 1)
  })
  it('should update on props change', () => {
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()

    assert.strictDeepEqual(view.dependencyMap, { foo: true })
    const hasUpdate = view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'bar',
      }
    )
    assert.strictEqual(hasUpdate, true)
    assert.strictDeepEqual(view.dependencyMap, { bar: true })
  })
  it('should not update when there is no props change', () => {
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'baz',
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.strictDeepEqual(view.dependencyMap, { foo: true })
    const hasUpdate = view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'foo',
      }
    )
    assert.strictEqual(hasUpdate, false)
    assert.strictDeepEqual(view.dependencyMap, { foo: true })
  })
  it('should rerender on state update', () => {
    let renderCount = 0
    const rootModule = {
      state: {
        foo: 'bar',
      },
      sequences: {
        methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const controller = App(rootModule)

    const view = new View({
      dependencies: {
        foo: state`foo`,
        methodCalled: sequences`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 1)
        assert.strictDeepEqual(stateChanges[0].path, ['foo'])
        assert.strictEqual(force, undefined)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    assert.strictEqual(renderCount, 0)
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
    })
    controller.getSequence('methodCalled')()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar2')
    })
    assert.strictEqual(renderCount, 1)
  })
  it('should render only ones where multiple state changes', () => {
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        test: [
          ({ store }) => {
            store.set(state`foo`, 'bar2')
            store.set(state`bar`, 'foo2')
          },
        ],
      },
    }
    const controller = App(rootModule)
    let renderCount = 0
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 2)
        assert.strictDeepEqual(stateChanges[0].path, ['foo'])
        assert.strictDeepEqual(stateChanges[1].path, ['bar'])
        assert.strictEqual(force, undefined)
        renderCount++
      },
    })
    view.mount()
    assert.strictEqual(renderCount, 0)
    controller.getSequence('test')()
    assert.strictEqual(renderCount, 1)
  })
  it('should rerender when controller flush method called with force option', () => {
    let renderCount = 0
    const rootModule = {
      state: {
        foo: 'bar',
        computedFoo: (get) => get(state`foo`),
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`computedFoo`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 0)
        assert.strictEqual(force, true)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    view.render()
    assert.strictEqual(renderCount, 0)
    view.controller.flush(true)
    assert.strictEqual(renderCount, 1)
  })
  it('should rerender on parent dep replacement', () => {
    let renderCount = 0
    const rootModule = {
      state: {
        foo: {
          bar: 'baz',
        },
      },
      sequences: {
        methodCalled: [({ store }) => store.set(state`foo`, { bar: 'baz2' })],
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`foo.bar`,
        methodCalled: sequences`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 1)
        assert.strictDeepEqual(stateChanges[0].path, ['foo'])
        assert.strictEqual(force, undefined)
        renderCount++
      },
    })
    view.mount()
    assert.strictEqual(renderCount, 0)
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'baz')
    })
    controller.getSequence('methodCalled')()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'baz2')
    })
    assert.strictEqual(renderCount, 1)
  })
  it('should only rerender affected components', () => {
    let renderCountView1 = 0
    let renderCountView2 = 0
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      sequences: {
        methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const controller = App(rootModule)
    const view1 = new View({
      dependencies: {
        bar: state`bar`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        renderCountView1++
      },
    })
    view1.mount()
    const view2 = new View({
      dependencies: {
        foo: state`foo`,
        methodCalled: sequences`methodCalled`,
      },
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 1)
        assert.strictDeepEqual(stateChanges[0].path, ['foo'])
        assert.strictEqual(force, undefined)
        renderCountView2++
      },
    })
    view2.mount()
    assert.strictEqual(renderCountView1, 0)
    assert.strictEqual(renderCountView2, 0)
    controller.getSequence('methodCalled')()
    assert.strictEqual(renderCountView1, 0)
    assert.strictEqual(renderCountView2, 1)
  })
  it('should register dependencies with "get"', () => {
    let renderCount = 0
    const rootModule = {
      state: {
        foo: 'bar',
      },
      sequences: {
        methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const controller = App(rootModule)

    const view = new View({
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 1)
        assert.strictDeepEqual(stateChanges[0].path, ['foo'])
        assert.strictEqual(force, undefined)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    assert.strictEqual(renderCount, 0)
    view.render({}, ({ get }) => {
      get(state`foo`)
    })
    view.update()
    controller.getSequence('methodCalled')()
    assert.strictEqual(renderCount, 1)
  })
  it('should register dependencies with "get.path"', () => {
    const paths = []

    const view = new View({
      controller: App({ state: { selected: 'bong' } }),
      props: { baz: 'man' },
    })
    view.mount()
    view.render({ baz: 'man' }, ({ get }) => {
      paths.push(get.path(state`foo`))
      paths.push(get.path(props`poo.par`))
      paths.push(get.path(state`foo.bar.${props`baz`}`))
      paths.push(get.path(state`foo.${state`selected`}`))
    })
    assert.strictDeepEqual(paths, ['foo', 'poo.par', 'foo.bar.man', 'foo.bong'])
  })
  it('should register computed dependencies with "get"', () => {
    let renderCount = 0
    const rootModule = {
      state: {
        foo: 'bar',
        fooComputed: (get) => get(state`foo`),
      },
      sequences: {
        methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const controller = App(rootModule)

    const view = new View({
      controller,
      onUpdate: (stateChanges, force) => {
        assert.strictEqual(stateChanges.length, 1)
        assert.strictDeepEqual(stateChanges[0].path, ['foo'])
        assert.strictEqual(force, undefined)
        view.updateFromState(stateChanges, null, force)
        renderCount++
      },
    })
    view.mount()
    assert.strictEqual(renderCount, 0)
    view.render({}, ({ get }) => {
      get(state`fooComputed`)
    })
    controller.getSequence('methodCalled')()
    assert.strictEqual(renderCount, 1)
  })
  it('should register reactions', () => {
    let reactionValue = null
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      sequences: {
        methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
      },
    }
    const controller = App(rootModule)

    const view = new View({
      controller,
    })
    view.mount()
    view.render({}, ({ reaction }) => {
      reaction(
        'someName',
        {
          foo: state`foo`,
        },
        ({ foo, get }) => {
          reactionValue = foo + get(state`bar`)
        }
      )
    })
    view.update()
    controller.getSequence('methodCalled')()
    assert.strictEqual(reactionValue, 'bar2baz')
  })
  describe('STRICT render update', () => {
    it('should update when parent path changes', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: {
            bar: 'baz',
          },
        },
        sequences: {
          methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.bar`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['foo'])
          assert.strictEqual(force, undefined)
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 'baz')
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, undefined)
      })
      assert.strictEqual(renderCount, 1)
    })

    it('should return array', () => {
      const rootModule = {
        state: {
          map: '',
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.*`,
        },
        controller,
      })
      view.mount()
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.foo, [])
      })
      assert.strictDeepEqual(view.dependencyMap, { 'foo.*': true })
    })

    it('should be able to override immediate child interest', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: [
            {
              bar: 'baz',
            },
          ],
        },
        sequences: {
          methodCalled: [({ store }) => store.set(state`foo.0.bar`, 'baz2')],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.*`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo[0], '0')
        assert.strictDeepEqual(view.dependencyMap, { 'foo.*': true })
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo[0], '0')
        assert.strictEqual(componentProps.foo[0], '0')
      })
      assert.strictEqual(renderCount, 0)
    })

    it('should by default update when nested children update', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: {
            bar: {
              baz: 'value',
            },
          },
        },
        sequences: {
          methodCalled: [
            ({ store }) => store.set(state`foo.bar.baz`, 'value2'),
          ],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.strictEqual(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, { 'foo.**': true })
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo.bar.baz, 'value')
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo.bar.baz, 'value2')
      })
      assert.strictEqual(renderCount, 1)
    })

    it('should update when undefined path becoming defined', () => {
      let renderCount = 0
      const rootModule = {
        state: {},
        sequences: {
          methodCalled: [
            ({ store }) => store.set(state`foo.bar.baz`, 'value2'),
          ],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.bar.baz`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.strictEqual(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, { 'foo.bar.baz': true })
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, undefined)
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 'value2')
      })
      assert.strictEqual(renderCount, 1)
    })

    it('should update when undefined path becoming defined deeply', () => {
      let renderCount = 0
      const rootModule = {
        state: {},
        sequences: {
          methodCalled: [set(state`scope.scopeid.user.userid`, 'bong')],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          user: state`scope.scopeid.user.**`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, [
            'scope',
            'scopeid',
            'user',
            'userid',
          ])
          assert.strictEqual(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, {
        'scope.scopeid.user.**': true,
      })
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.user, undefined)
      })

      controller.getSequence('methodCalled')()
      assert.strictEqual(renderCount, 1)
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.user, { userid: 'bong' })
      })
    })
    it('should by default update when nested children update with array', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: [
            {
              bar: 'value',
            },
          ],
        },
        sequences: {
          methodCalled: [({ store }) => store.set(state`foo.0.bar`, 'value2')],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['foo', '0', 'bar'])
          assert.strictEqual(force, undefined)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, { 'foo.**': true })
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo[0].bar, 'value')
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo[0].bar, 'value2')
      })
      assert.strictEqual(renderCount, 1)
    })

    it('should by default update when nested children update using COMPUTE', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: {
            bar: {
              baz: 'value',
            },
          },
          computedFoo: (get) => get(state`foo`),
        },
        sequences: {
          methodCalled: [
            ({ store }) => store.set(state`foo.bar.baz`, 'value2'),
          ],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`computedFoo`,
          methodCalled: sequences`methodCalled`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['foo', 'bar', 'baz'])
          assert.strictEqual(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.strictDeepEqual(view.dependencyMap, { 'foo.**': true })
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, { 'foo.**': true })
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo.bar.baz, 'value')
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo.bar.baz, 'value2')
      })
      assert.strictEqual(renderCount, 1)
    })
  })
  describe('Compute', () => {
    it('should allow use of Compute as state dependency and access props', () => {
      const rootModule = {
        state: {
          foo: (get) => get(props`foo`) + 'baz',
        },
      }
      const testProps = {
        foo: 'bar',
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo`,
        },
        props: testProps,
        controller,
      })
      view.mount()
      assert.strictDeepEqual(view.dependencyMap, {})
      view.render(testProps, (props) => {
        assert.strictEqual(props.foo, 'barbaz')
      })
    })
    it('should have access to state through state argument', () => {
      const rootModule = {
        state: {
          foo: 'bar',
          fooComputed: (get) => get(state`foo`),
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`fooComputed`,
        },
        controller,
      })
      view.mount()
      assert.strictDeepEqual(view.dependencyMap, {
        foo: true,
      })
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 'bar')
      })
    })
    it('should track state', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: 'bar',
          fooComputed: (get) => get(state`foo`),
        },
        sequences: {
          methodCalled: [({ store }) => store.set(state`foo`, 'bar2')],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`fooComputed`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['foo'])
          assert.strictEqual(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.strictDeepEqual(view.dependencyMap, {
            foo: true,
          })
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, {
        foo: true,
      })
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 'bar')
      })
      controller.getSequence('methodCalled')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 'bar2')
      })
      assert.strictEqual(renderCount, 1)
    })
    it('should update dependency map when Compute is rerun', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          map: {},
          foo: (get) =>
            get(state`map.*`).filter((key) => get(state`map.${key}.awesome`)),
        },
        sequences: {
          changeState: [
            ({ store }) => store.set(state`map.1`, { awesome: true }),
          ],
          changeState2: [({ store }) => store.set(state`map.1.awesome`, false)],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          if (!renderCount) {
            assert.strictEqual(stateChanges.length, 1)
            assert.strictDeepEqual(stateChanges[0].path, ['map', '1'])
            assert.strictEqual(force, undefined)
            view.updateFromState(stateChanges, null, force)
            assert.strictDeepEqual(view.dependencyMap, {
              'map.*': true,
              'map.1.awesome': true,
            })
            renderCount++
          } else {
            assert.strictEqual(stateChanges.length, 1)
            assert.strictDeepEqual(stateChanges[0].path, [
              'map',
              '1',
              'awesome',
            ])
            assert.strictEqual(force, undefined)
            view.updateFromState(stateChanges, null, force)
            assert.strictDeepEqual(view.dependencyMap, {
              'map.*': true,
              'map.1.awesome': true,
            })
            renderCount++
          }
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, {
        'map.*': true,
      })

      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.foo, [])
      })
      view.controller.getSequence('changeState')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, '1')
      })
      assert.strictEqual(renderCount, 1)
      view.controller.getSequence('changeState2')()
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.foo, [])
      })
      assert.strictEqual(renderCount, 2)
    })
    it('should update dependency map when nested Compute is rerun', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          foo: (get) => ({
            nested: get(state`bar`) + 1,
          }),
          bar: 2,
        },
        sequences: {
          changeState: [({ store }) => store.set(state`bar`, 3)],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          foo: state`foo.nested`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 3)
      })
      view.controller.getSequence('changeState')()
      view.render({}, (componentProps) => {
        assert.strictEqual(componentProps.foo, 4)
      })
      assert.strictEqual(renderCount, 1)
    })
    it('should handle complex state changes', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          user: {
            projects: ['0', '1'],
          },
          projects: {
            '0': 'foo',
            '1': 'bar',
            '2': 'baz',
          },
          userProjects: (get) =>
            get(state`user.projects`).map((projectKey) =>
              get(state`projects.${projectKey}`)
            ),
        },
        sequences: {
          changeState: [({ store }) => store.push(state`user.projects`, '2')],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          projects: state`userProjects`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, ['user', 'projects'])
          assert.strictEqual(force, undefined)
          view.updateFromState(stateChanges, null, force)
          assert.strictDeepEqual(view.dependencyMap, {
            'projects.0': true,
            'projects.1': true,
            'projects.2': true,
            'user.projects.**': true,
          })
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      assert.strictDeepEqual(view.dependencyMap, {
        'projects.0': true,
        'projects.1': true,
        'user.projects.**': true,
      })
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.projects, ['foo', 'bar'])
      })
      view.controller.getSequence('changeState')()
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.projects, ['foo', 'bar', 'baz'])
      })
      assert.strictEqual(renderCount, 1)
    })
    it('should handle strict deps', () => {
      let renderCount = 0
      const rootModule = {
        state: {
          user: {
            projects: ['0', '1'],
          },
          projects: {
            '0': { title: '0' },
            '1': { title: '1' },
          },
          userProjects: (get) =>
            get(state`user.projects`).map((projectKey) =>
              get(state`projects.${projectKey}`)
            ),
        },
        sequences: {
          changeState: [
            ({ store }) => store.set(state`projects.1.title`, 'woop'),
          ],
        },
      }
      const controller = App(rootModule)
      const view = new View({
        dependencies: {
          projects: state`userProjects`,
        },
        controller,
        onUpdate: (stateChanges, force) => {
          assert.strictEqual(stateChanges.length, 1)
          assert.strictDeepEqual(stateChanges[0].path, [
            'projects',
            '1',
            'title',
          ])
          assert.strictEqual(force, undefined)
          view.updateFromState(stateChanges, null, force)
          renderCount++
        },
      })
      view.mount()
      assert.strictEqual(renderCount, 0)
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.projects, [
          { title: '0' },
          { title: '1' },
        ])
      })
      view.controller.getSequence('changeState')()
      view.render({}, (componentProps) => {
        assert.strictDeepEqual(componentProps.projects, [
          { title: '0' },
          { title: 'woop' },
        ])
      })
      assert.strictEqual(renderCount, 1)
    })
  })
  it('should handle props updating state deps', () => {
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'baz',
      },
      sequences: {
        changeState: [({ store }) => store.set(state`bar`, 'baz2')],
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'foo',
      },
    })
    view.mount()
    assert.strictDeepEqual(view.dependencyMap, { foo: true })
    view.render(
      {
        path: 'foo',
      },
      (componentProps) => {
        assert.strictEqual(componentProps.foo, 'bar')
      }
    )
    view.onPropsUpdate(
      {
        path: 'foo',
      },
      {
        path: 'bar',
      }
    )
    assert.strictDeepEqual(view.dependencyMap, { bar: true })
    view.render(
      {
        path: 'bar',
      },
      (componentProps) => {
        assert.strictEqual(componentProps.foo, 'baz')
      }
    )
    view.controller.getSequence('changeState')()
    view.render(
      {
        path: 'bar',
      },
      (componentProps) => {
        assert.strictEqual(componentProps.foo, 'baz2')
      }
    )
  })
  it('should handle props composition updating value', () => {
    const rootModule = {
      state: {
        field: {
          value: '',
        },
      },
      sequences: {
        changeState: [
          ({ store }) => {
            store.set(state`field.value`, 'foo')
            store.merge(state`field`, { mip: 'mop' })
          },
        ],
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        field: state`${props`path`}`,
      },
      controller,
      props: {
        path: 'field',
      },
    })
    view.mount()
    assert.strictDeepEqual(view.dependencyMap, { 'field.**': true })
    view.render(
      {
        path: 'field',
      },
      (componentProps) => {
        assert.strictDeepEqual(componentProps.field, {
          value: '',
        })
      }
    )
    view.controller.getSequence('changeState')()
    view.render(
      {
        path: 'field',
      },
      (componentProps) => {
        assert.strictDeepEqual(componentProps.field, {
          value: 'foo',
          mip: 'mop',
        })
      }
    )
  })
  it('should warn if prop is from the Cerebral state tree when initializing', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'You are passing an array to the component "Test" on prop "list" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.'
      )
    }
    const rootModule = {
      state: {
        foo: 'bar',
        list: [],
      },
    }
    const controller = App(rootModule, {
      devtools: {
        warnStateProps: true,
        preventExternalstores: true,
        init() {},
        send() {},
        updateWatchMap() {},
        updateComputedMap() {},
        sendWatchMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      props: {
        list: controller.getState('list'),
      },
      displayName: 'Test',
    })
    assert.strictEqual(view._verifyPropsWarned, true)
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
  })
  it('should warn if prop is from the Cerebral state tree when updating props', () => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'You are passing an object to the component "Test" on prop "list" which is from the Cerebral state tree. You should not do this, but rather connect it directly to this component. This will optimize the component and avoid any rerender issues.'
      )
    }
    const rootModule = {
      state: {
        foo: 'bar',
        list: {},
      },
    }
    const controller = App(rootModule, {
      devtools: {
        warnStateProps: true,
        preventExternalstores: true,
        init() {},
        send() {},
        updateWatchMap() {},
        updateComputedMap() {},
        sendWatchMap() {},
      },
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
      },
      controller,
      props: {
        list: '',
      },
      displayName: 'Test',
    })
    view.mount()
    assert.strictEqual(view._verifyPropsWarned, false)
    view.onPropsUpdate(
      {
        list: '',
      },
      {
        list: controller.getState('list'),
      }
    )
    assert.strictEqual(view._verifyPropsWarned, true)
    assert.strictEqual(warnCount, 1)
    console.warn = originWarn
  })
  it('should handle computed from controller', () => {
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'baz',
        test: (get) => get(moduleState`foo`).toUpperCase(),
      },
    }
    const controller = App(rootModule)
    const view = new View({
      dependencies: {
        foo: state`test`,
        bar: state`bar`,
      },
      controller,
    })
    view.mount()
    assert.strictDeepEqual(view.dependencyMap, { foo: true, bar: true })
  })
})
