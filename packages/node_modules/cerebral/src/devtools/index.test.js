/* eslint-env mocha */
/* global VERSION */
'use strict'

import { Server, WebSocket } from 'mock-socket'
import { sequences, state } from '../tags'

import App from '../'
import { Devtools } from './'
import { FunctionTreeExecutionError } from 'function-tree'
import View from '../View'
import Watch from '../Watch'
import assert from 'assert'

const version = VERSION

Devtools.prototype.createSocket = function() {
  this.ws = new WebSocket(`ws://${this.host}`)
}

Devtools.prototype.reconnect = function() {
  this.reconnectTimeout = setTimeout(() => {
    this.init()
  }, this.reconnectInterval)
}

Devtools.prototype.destroy = function() {
  clearTimeout(this.reconnectTimeout)
}

function toJSON(value) {
  return JSON.parse(JSON.stringify(value))
}

let devtools

describe('Devtools', () => {
  afterEach(() => {
    devtools && devtools.destroy()
    Watch.nextWatchId = 0
  })
  it('should throw when host is not set', () => {
    assert.throws(
      () => {
        devtools = new Devtools() // eslint-disable-line no-new
      },
      (err) => {
        if (err instanceof Error) {
          return (
            err.message === 'Devtools: You have to pass in the "host" option'
          )
        }
      }
    )
  })
  it('should init correctly and work when debugger is open when app loads', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = []
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        messages.push(message.type)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
    })
    const rootModule = {}
    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    assert.strictEqual(controller.devtools.isConnected, false)
    setTimeout(() => {
      assert.strictDeepEqual(messages, ['ping', 'init', 'watchMap'])
      assert.strictEqual(controller.devtools.isConnected, true)
      assert.strictEqual(controller.devtools.reconnectInterval, 5000)
      assert.strictEqual(controller.devtools.doReconnect, true)
      assert.strictDeepEqual(controller.devtools.debuggerWatchMap, {})
      assert.strictEqual(controller.devtools.storeMutations, true)
      assert.strictEqual(controller.devtools.preventExternalMutations, true)
      assert.strictEqual(controller.devtools.preventPropsReplacement, false)
      assert.strictEqual(controller.devtools.bigComponentsWarning, 10)

      assert.strictDeepEqual(controller.devtools.controller, controller)
      assert.strictDeepEqual(
        controller.devtools.originalRunTreeFunction,
        controller.run
      )
      assert.strictEqual(controller.devtools.isResettingDebugger, false)
      assert.strictEqual(
        controller.devtools.initialModelString,
        JSON.stringify(controller.model.get())
      )
      mockServer.stop(done)
    }, 70)
  })
  it('should warn, try to reconnect to Debugger and send bulk message after connecting', (done) => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'Debugger application is not running on selected port... will reconnect automatically behind the scenes'
      )
    }
    const originError = console.error
    console.error = function(...args) {
      const [err] = args
      if (
        err &&
        String(err) === `WebSocket connection to 'ws://localhost:8585/' failed`
      ) {
        // ignore
      } else {
        originError(...args)
      }
    }

    function actionA({ store }) {
      assert.ok(true)
      store.set(state`foo`, 'foo')
    }

    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        test: [actionA],
      },
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      reconnectInterval: 500,
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        test: sequences`test`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })
    assert.strictEqual(controller.devtools.isConnected, false)
    view.controller.getSequence('test')()
    let mockServer
    const messages = {}
    const messageTypes = []
    setTimeout(() => {
      mockServer = new Server('ws://localhost:8585')
      mockServer.on('connection', (server) => {
        server.on('message', (event) => {
          const message = JSON.parse(event)
          switch (message.type) {
            case 'pong':
              server.send(JSON.stringify({ type: 'ping' }))
              break
            case 'ping':
              server.send(JSON.stringify({ type: 'pong' }))
              break
            case 'init':
              break
            default:
              messageTypes.push(message.type)
              messages[message.type] = message
              break
          }
        })
      })
    }, 400)
    assert.strictEqual(controller.devtools.backlog.length, 4)
    setTimeout(() => {
      assert.strictDeepEqual(messageTypes, ['bulk', 'watchMap'])

      assert.strictEqual(controller.devtools.isConnected, true)
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)

      let bulkMessages = messages.bulk.data.messages.map(JSON.parse)
      const bulkMessagesTypes = []
      bulkMessages = bulkMessages.reduce((acc, message) => {
        bulkMessagesTypes.push(message.type)
        if (Array.isArray(acc[message.type])) {
          acc[message.type].push(message)
        } else {
          acc[message.type] = [message]
        }
        return acc
      }, {})
      assert.strictDeepEqual(bulkMessagesTypes, [
        'executionStart',
        'execution',
        'execution',
        'executionEnd',
      ])
      assert.strictEqual(bulkMessages.executionStart[0].data.execution.name, 'test')
      assert.strictEqual(bulkMessages.execution.length, 2)
      assert.ok(bulkMessages.execution[0].data.execution)
      assert.strictEqual(bulkMessages.execution[0].source, 'c')
      assert.strictEqual(bulkMessages.execution[0].version, version)
      assert.strictDeepEqual(bulkMessages.execution[0].data.execution.payload, {})

      assert.ok(bulkMessages.execution[1].data.execution)
      assert.strictDeepEqual(bulkMessages.execution[1].data.execution.payload, {})
      assert.strictEqual(bulkMessages.execution[1].data.execution.data.method, 'set')
      assert.strictDeepEqual(bulkMessages.execution[1].data.execution.data.args, [
        ['foo'],
        'foo',
      ])
      assert.strictEqual(
        bulkMessages.execution[1].data.execution.data.type,
        'mutation'
      )
      assert.strictEqual(bulkMessages.execution[1].data.execution.data.color, '#333')

      assert.ok(bulkMessages.executionEnd[0].data.execution)

      assert.strictEqual(warnCount, 1)
      console.warn = originWarn
      console.error = originError
      mockServer.stop(done)
    }, 1050)
  })
  it('should set component details and watch executions', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = {}
    const messageTypes = []
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          case 'init':
            break
          case 'execution':
            messageTypes.push(message.type)
            if (Array.isArray(messages[message.type])) {
              messages[message.type].push(message)
            } else {
              messages[message.type] = [message]
            }
            break
          default:
            messageTypes.push(message.type)
            messages[message.type] = message
            break
        }
      })
    })
    function actionA({ path, store }) {
      assert.ok(true)
      store.set(state`foo`, 'foo')
      return path.success()
    }
    function actionB() {
      assert.ok(true)
      return { bar: 'baz' }
    }

    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        test: [
          actionA,
          {
            success: [actionB],
          },
        ],
      },
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        test: sequences`test`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })

    setTimeout(() => {
      assert.strictDeepEqual(messageTypes, ['watchMap'])
      assert.strictEqual(controller.devtools.isConnected, true)

      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)

      assert.strictEqual(messages.watchMap.source, 'c')
      assert.strictDeepEqual(messages.watchMap.data.watchMap.foo, [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(messages.watchMap.data.watchMap.bar, [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(messages.watchMap.data.updates, [])

      view.controller.getSequence('test')({
        foo: 'bar',
      })

      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)

      assert.strictDeepEqual(messageTypes, [
        'watchMap',
        'executionStart',
        'execution',
        'execution',
        'executionPathStart',
        'execution',
        'executionFunctionEnd',
        'executionEnd',
        'watchMap',
      ])
      assert.ok(messages.executionStart.data.execution)
      assert.strictEqual(messages.executionStart.source, 'c')

      assert.strictEqual(messages.execution.length, 3)
      assert.ok(messages.execution[0].data.execution)
      assert.strictEqual(messages.execution[0].source, 'c')
      assert.strictEqual(messages.execution[0].version, version)
      assert.strictDeepEqual(messages.execution[0].data.execution.payload, {
        foo: 'bar',
      })

      assert.ok(messages.execution[1].data.execution)
      assert.strictEqual(messages.execution[1].source, 'c')
      assert.strictEqual(messages.execution[1].version, version)
      assert.strictDeepEqual(messages.execution[1].data.execution.payload, {
        foo: 'bar',
      })
      assert.strictEqual(messages.execution[1].data.execution.data.method, 'set')
      assert.strictDeepEqual(messages.execution[1].data.execution.data.args, [
        ['foo'],
        'foo',
      ])
      assert.strictEqual(messages.execution[1].data.execution.data.type, 'mutation')
      assert.strictEqual(messages.execution[1].data.execution.data.color, '#333')

      assert.ok(messages.executionPathStart.data.execution)
      assert.strictEqual(messages.executionPathStart.source, 'c')
      assert.strictEqual(messages.executionPathStart.version, version)
      assert.strictEqual(messages.executionPathStart.data.execution.path, 'success')

      assert.ok(messages.execution[2].data.execution)
      assert.strictEqual(messages.execution[2].source, 'c')
      assert.strictEqual(messages.execution[2].version, version)
      assert.strictDeepEqual(messages.execution[2].data.execution.payload, {
        foo: 'bar',
      })

      assert.ok(messages.executionFunctionEnd.data.execution)
      assert.strictEqual(messages.executionFunctionEnd.source, 'c')
      assert.strictEqual(messages.executionFunctionEnd.version, version)
      assert.strictDeepEqual(messages.executionFunctionEnd.data.execution.output, {
        bar: 'baz',
      })

      assert.ok(messages.executionEnd.data.execution)
      assert.strictEqual(messages.executionEnd.version, version)
      assert.strictEqual(messages.executionEnd.source, 'c')
      mockServer.stop(done)
    }, 70)
  })
  it('should watch sequence execution error', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    const messages = {}
    const messageTypes = []
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          case 'init':
            break
          case 'execution':
            messageTypes.push(message.type)
            if (Array.isArray(messages[message.type])) {
              messages[message.type].push(message)
            } else {
              messages[message.type] = [message]
            }
            break
          default:
            messageTypes.push(message.type)
            messages[message.type] = message
            break
        }
      })
    })
    function actionA() {
      return {
        foo: 'bar',
      }
    }
    let errorCount = 0
    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        test: [
          actionA,
          {
            success: [],
          },
        ],
      },
      catch: [
        [
          FunctionTreeExecutionError,
          [
            ({ props }) => {
              errorCount++
              assert.ok(
                props.error.message.match(
                  /needs to be a path of either success/
                )
              )
            },
          ],
        ],
      ],
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
      throwToConsole: false,
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        test: sequences`test`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })

    setTimeout(() => {
      controller.getSequence('test')()
      assert.strictEqual(errorCount, 1)
      assert.strictDeepEqual(messageTypes, [
        'watchMap',
        'executionStart',
        'execution',
        'executionFunctionError',
        'executionStart',
        'execution',
        'executionEnd',
      ])
      mockServer.stop(done)
    }, 70)
  })
  it('should reset the state', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
          default:
            break
        }
      })
      setTimeout(() => {
        server.send(JSON.stringify({ type: 'reset' }))
      }, 150)
    })
    function actionA({ path, store }) {
      store.set(state`foo`, 'foo')
      return path.success()
    }
    function actionB() {
      return { bar: 'baz' }
    }

    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        test: [
          actionA,
          {
            success: [actionB],
          },
        ],
      },
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
        test: sequences`test`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })

    setTimeout(() => {
      assert.strictDeepEqual(JSON.parse(controller.devtools.initialModelString), {
        foo: 'bar',
        bar: 'foo',
      })
      assert.strictEqual(controller.devtools.isConnected, true)

      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)

      controller.getSequence('test')({
        foo: 'bar',
      })
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })
      assert.strictDeepEqual(JSON.parse(controller.devtools.initialModelString), {
        foo: 'bar',
        bar: 'foo',
      })
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, type: 'View', id: 'Watch_0' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)
    }, 70)

    setTimeout(() => {
      assert.strictDeepEqual(
        controller.model.state,
        JSON.parse(controller.devtools.initialModelString)
      )
      assert.strictDeepEqual(controller.devtools.backlog, [])
      assert.strictDeepEqual(controller.devtools.mutations, [])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)
      mockServer.stop(done)
    }, 300)
  })
  it('should warn when remember message sent if storeMutations option is false', (done) => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'Cerebral Devtools - You tried to time travel, but you have turned off storing of mutations'
      )
    }
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
      setTimeout(() => {
        server.send(JSON.stringify({ type: 'remember', data: 0 }))
      }, 70)
    })
    const rootModule = {}
    devtools = new Devtools({
      host: 'localhost:8585',
      reconnect: true,
      storeMutations: false,
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    setTimeout(() => {
      assert.strictEqual(warnCount, 1)
      assert.strictEqual(controller.devtools.storeMutations, false)
      console.warn = originWarn
      mockServer.stop(done)
    }, 100)
  })
  it('should travel back in time', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
      setTimeout(() => {
        server.send(JSON.stringify({ type: 'remember', data: 1 }))
      }, 200)
      setTimeout(() => {
        server.send(JSON.stringify({ type: 'remember', data: 0 }))
      }, 400)
      setTimeout(() => {
        server.send(JSON.stringify({ type: 'remember', data: 1 }))
      }, 600)
    })
    function actionA({ store }) {
      store.set(state`foo`, 'foo')
    }
    function actionB({ store }) {
      store.set(state`bar`, 'bar')
    }

    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        testA: [actionA],
        testB: [actionB],
      },
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    let rememberCount = 0
    controller.on('remember', (datetime) => {
      rememberCount++
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })

    setTimeout(() => {
      assert.strictDeepEqual(JSON.parse(controller.devtools.initialModelString), {
        foo: 'bar',
        bar: 'foo',
      })
      assert.strictEqual(controller.devtools.isConnected, true)

      controller.getSequence('testA')()
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })
      controller.getSequence('testB')()
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'bar',
      })
      assert.strictDeepEqual(JSON.parse(controller.devtools.initialModelString), {
        foo: 'bar',
        bar: 'foo',
      })
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, id: 'Watch_0', type: 'View' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, id: 'Watch_0', type: 'View' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)
      assert.strictEqual(controller.devtools.mutations.length, 2)
      assert.strictEqual(rememberCount, 0)
    }, 70)

    setTimeout(() => {
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })
      assert.strictEqual(controller.devtools.mutations.length, 2)
      assert.strictEqual(rememberCount, 1)
    }, 300)
    setTimeout(() => {
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'bar',
      })
      assert.strictEqual(controller.devtools.mutations.length, 2)
      assert.strictEqual(rememberCount, 2)
    }, 500)
    setTimeout(() => {
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })
      assert.strictEqual(controller.devtools.mutations.length, 2)
      assert.strictEqual(rememberCount, 3)

      mockServer.stop(done)
    }, 800)
  })
  it('should warn when the sequence fired while debugger is remembering state', (done) => {
    let warnCount = 0
    const originWarn = console.warn
    console.warn = function(...args) {
      warnCount++
      assert.strictEqual(
        args[0],
        'The sequence "testB" fired while debugger is remembering state, it was ignored'
      )
    }
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
      setTimeout(() => {
        server.send(JSON.stringify({ type: 'remember', data: 1 }))
      }, 150)
    })
    function actionA({ store }) {
      store.set(state`foo`, 'foo')
    }
    function actionB({ store }) {
      store.set(state`bar`, 'bar')
    }

    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
      sequences: {
        testA: [actionA],
        testB: [actionB],
      },
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })

    setTimeout(() => {
      assert.strictDeepEqual(JSON.parse(controller.devtools.initialModelString), {
        foo: 'bar',
        bar: 'foo',
      })
      assert.strictEqual(controller.devtools.isConnected, true)

      controller.getSequence('testA')()
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })
      controller.getSequence('testB')()
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'bar',
      })
      assert.strictDeepEqual(JSON.parse(controller.devtools.initialModelString), {
        foo: 'bar',
        bar: 'foo',
      })
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.foo), [
        { name: 'Test', executedCount: 1, id: 'Watch_0', type: 'View' },
      ])
      assert.strictDeepEqual(toJSON(controller.devtools.debuggerWatchMap.bar), [
        { name: 'Test', executedCount: 1, id: 'Watch_0', type: 'View' },
      ])
      assert.strictEqual(controller.devtools.debuggerWatchMap.test, undefined)
      assert.strictEqual(controller.devtools.mutations.length, 2)
    }, 70)

    setTimeout(() => {
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })
      assert.strictEqual(controller.devtools.mutations.length, 2)
      controller.getSequence('testB')()
      assert.strictDeepEqual(controller.model.state, {
        foo: 'foo',
        bar: 'foo',
      })

      assert.strictEqual(warnCount, 1)
      console.warn = originWarn
      mockServer.stop(done)
    }, 300)
  })
  it('should change model state when debugger model state changed', (done) => {
    const mockServer = new Server('ws://localhost:8585')
    mockServer.on('connection', (server) => {
      server.on('message', (event) => {
        const message = JSON.parse(event)
        switch (message.type) {
          case 'pong':
            server.send(JSON.stringify({ type: 'ping' }))
            break
          case 'ping':
            server.send(JSON.stringify({ type: 'pong' }))
            break
        }
      })
      setTimeout(() => {
        server.send(
          JSON.stringify({
            type: 'changeModel',
            data: { path: ['foo'], value: 'baz' },
          })
        )
      }, 70)
    })

    const rootModule = {
      state: {
        foo: 'bar',
        bar: 'foo',
      },
    }
    devtools = new Devtools({
      host: 'localhost:8585',
      disableDebounce: true,
    })
    const controller = App(rootModule, {
      devtools,
    })
    const view = new View({
      dependencies: {
        foo: state`foo`,
        bar: state`bar`,
      },
      controller,
      displayName: 'Test',
      onUpdate: (stateChanges, force) => {
        view.updateFromState(stateChanges, null, force)
      },
    })
    view.mount()
    view.render({}, (componentProps) => {
      assert.strictEqual(componentProps.foo, 'bar')
      assert.strictEqual(componentProps.bar, 'foo')
    })

    setTimeout(() => {
      assert.strictDeepEqual(controller.model.state, {
        foo: 'baz',
        bar: 'foo',
      })
      mockServer.stop(done)
    }, 100)
  })
})
